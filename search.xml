<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows包管理工具</title>
      <link href="/2023/03/08/Windows%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/03/08/Windows%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果是使用 Mac 系统，我们可以使用 brew 这款包管理工具来方便的安装各种基于命令行的软件。</p><p>如果是使用 Linux 系统，我们可以使用各个发行版自带的包管理工具，比如 RedHat 中的 Yum，Ubuntu 中的 apt 等等。</p><p>如果是使用 Windows 系统呢？我推荐使用 Chocolatey 这款包管理工具。</p><span id="more"></span><h3 id="使用前置条件"><a href="#使用前置条件" class="headerlink" title="使用前置条件"></a>使用前置条件</h3><p>在使用之前，请先确保系统环境达到以下要求：</p><ul><li>操作系统版本高于 Windows 7 &#x2F; Windows 2003。</li><li>PowerShell 2</li><li>NET Framework 4+</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装有两种方式，分别是通过 Cmd 方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</span><br></pre></td></tr></table></figure><p>或者通过 PowerShell 方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，上面两种途径都必须通过 <em><strong>administrative shell</strong></em> 的方式运行。</p></blockquote><p>安装完成之后，打开 PowerShell 窗口，然后输入<code>choco</code>来验证是否安装成功:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1589766983040-e2943bea-1b47-49d5-9099-ae3cc856d66a.png"></p><h3 id="使用-choco-来安装软件"><a href="#使用-choco-来安装软件" class="headerlink" title="使用 choco 来安装软件"></a>使用 choco 来安装软件</h3><p>然后，我们可以使用 choco 来安装一款软件，这里以 Packer 作为示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install packer</span><br></pre></td></tr></table></figure><p>安装成功如下图所示:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1589767638124-83b6eb08-8755-4baa-b059-d9f14c42560a.png"></p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 包管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vagrant</title>
      <link href="/2023/03/08/Vagrant/"/>
      <url>/2023/03/08/Vagrant/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我个人很喜欢使用 Vagrant，如果要说一个理由，那是因为它简单，就和 Docker 一样简单。</p><p>那么有了 Docker 为什么还要提 Vagrant 呢？有如下原因:</p><ol><li>在一个团队内，大家都使用 Docker，但是 Docker 在不同的操作系统上会有不同的表现。使用了 Vagrant 统一了 Docker 的运行环境，统一为 Linux。</li><li>你有没有想过，如果本地的 Docker 环境挂了呢？或者说本地的环境会随着时间的推移，而变得越来越复杂。而且不同项目之间，使用同一个 Docker 环境，没有隔离(比如只能运行一个版本的 Docker)。</li><li>如果你需要模拟多台服务器(集群)，那就只能选择虚拟机。</li></ol><p>所以，我推荐 Vagrant 和 Docker 组合使用，无需非此即彼。</p><span id="more"></span><h3 id="Vagrantfile"><a href="#Vagrantfile" class="headerlink" title="Vagrantfile"></a>Vagrantfile</h3><p>在构建 Docker Image 的时候，需要创建一个名为<code>Dockerfile</code>的文件。同样的，如果你想使用 Vagrant 创建一台虚拟机，也要创建一个名为 <code>Vagrantfile</code>的文件。</p><p>Vagrant 使用 Ruby 语言创作的，而 Vagrantfile 也是使用 Ruby 的语法。但你我都不需要为此去特意地学习 Ruby 这门语言，因为 Vagrantfile 非常的简单。它的基本结构如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">## To do some things;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>其所有的配置都包含在这个<code>do...end</code>的结构中, 要创建一台虚拟机，只有一个配置是必须的，指明虚拟机所依赖的 Image(镜像)。关于这个镜像，你可以在 <a href="https://app.vagrantup.com/boxes/search">Vagrant box Hub</a> 中查找自己所需的，配置如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  ## 这个镜像是我自己封装的,存储于七牛云。其他镜像如果直接从官方下载，可能被墙。</span><br><span class="line">config.vm.box = &quot;jinzhi/CentOS77-Mini&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>更多的配置，你可以参考官方的文档：<a href="https://www.vagrantup.com/docs/vagrantfile/">Vagrantfile - Vagrant by HashiCorp</a>。</p><h3 id="创建多台虚拟机"><a href="#创建多台虚拟机" class="headerlink" title="创建多台虚拟机"></a>创建多台虚拟机</h3><p>如果你需要启动多台虚拟机组建集群呢? 可以参考如下配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  ## 定义了一台名为 `web`的虚拟机</span><br><span class="line">config.vm.define &quot;web&quot; do |web|</span><br><span class="line">web.vm.box = &quot;jinzhi/Swoole&quot;</span><br><span class="line">end</span><br><span class="line">  ## 定义了一台名为`db`的虚拟机</span><br><span class="line">config.vm.define &quot;db&quot; do |db|</span><br><span class="line">db.vm.box = &quot;centos/7&quot;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在完成了<code>Vagrantfile</code>的定义之后，我们只需要执行 vagrant up 就可以启动配置文件中定义的虚拟机了。也可以使用如下的脚本创建多台与业务无关的虚拟机:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(2) do |config|</span><br><span class="line">config.vm.box = &quot;centos/7&quot;</span><br><span class="line">config.vm.network &quot;public_network&quot;</span><br><span class="line">(1..3).each do |i|</span><br><span class="line">config.vm.define &quot;vm#&#123;i&#125;&quot; do |node|</span><br><span class="line">config.vm.provider &quot;virtualbox&quot; do |node|</span><br><span class="line">node.name = &quot;vm#&#123;i&#125;&quot;  </span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里需要说明的是，vagrant up 这条命令会在当前目录下寻找 Vagrantfile，如果没有找到会一直沿着父级目录向上搜索，直到找到或根目录仍没有为止。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 Vagrant 这款工具，希望对你有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
            <tag> vagrant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlpineLinux</title>
      <link href="/2023/03/08/AlpineLinux/"/>
      <url>/2023/03/08/AlpineLinux/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><h3 id="关于-Alpine-Linux-发行版"><a href="#关于-Alpine-Linux-发行版" class="headerlink" title="关于 Alpine Linux 发行版"></a>关于 Alpine Linux 发行版</h3><p>在使用 Docker 的时候，我们会首先在 Docker Hub 中搜索已经存在并公开的 Image。比如我在 Docker Hub 上搜索 PHP(<a href="https://hub.docker.com/_php)%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA">https://hub.docker.com/_php)，如下图所示</a>:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1589196667010-ae7878bf-a1be-48f7-a9be-f432afd4ffea.png"></p><p>在其说明的文件中，可以看到其提供了 Alpine 版本(基于 Alpine Linux发行版)，正如很多 Docker 官方出版的镜像一样。</p><p>那么 Alpine Linux 和诸如 CentOS 之类的发行版之间存在着什么样的区别呢？下面这张截图来自于其官网，是最简单的对于其愿景和初衷的描述:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1589196884630-61463b9f-fbb5-4e04-b765-87161e111648.png"></p><span id="more"></span><p>其他点就是 Small(极小)、Simple(极简)、Secure(安全)。另外，在大标题的下方还有一行详细的描述:</p><blockquote><p><strong>Alpine Linux is a security-oriented, lightweight Linux distribution based on musl libc and busybox.</strong></p></blockquote><p>其大意是: Alpine Linux 是一个面向安全、轻量级的 Linux 发行版，基于 musl(轻量级的 C 语言标准库) 以及 Busybox(Linux 工具软件集合)。</p><p>然后我们再来看看 Docker 官方对其的描述:</p><blockquote><p>The image is only 5 MB in size and has access to a package repository that is much more complete than other BusyBox based images. This makes Alpine Linux a great image base for utilities and even production applications. </p></blockquote><p>大意是，从包仓库获取这个镜像仅仅只有 5MB 的大小，这方面远胜于其他基于 Busybox 的镜像。这使得 Alpine Linux 更适合成为应用程序在生产环境下的基础镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images alpine</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">alpine              latest              f70734b6a266        2 weeks ago         5.61MB</span><br></pre></td></tr></table></figure><h3 id="使用阿里云镜像"><a href="#使用阿里云镜像" class="headerlink" title="使用阿里云镜像"></a>使用阿里云镜像</h3><p>Alpine Linux 使用的是名为<code>apk</code>的包管理工具，默认的仓库源在国内的访问速度非常的慢。所以，需要换成国内的源地址，建议使用阿里云的镜像。其源配置文件为<code>/etc/apk/repositories</code>，修改如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27; /etc/apk/repositories</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
            <tag> alpine linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成GitLabEE许可证</title>
      <link href="/2023/03/08/%E7%94%9F%E6%88%90GitLabEE%E8%AE%B8%E5%8F%AF%E8%AF%81/"/>
      <url>/2023/03/08/%E7%94%9F%E6%88%90GitLabEE%E8%AE%B8%E5%8F%AF%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>本文将描述如何生成 GitLab 的许可证，用来激活 GitLab Ultimate 许可的所有功能，以满足项目实际所需。</p></blockquote><p>首先需要安装 <code>Gem</code> , 它是基于 Ruby 的打包系统，下文中我们将使用它来安装 Ruby 写的组件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install gem -y</span><br></pre></td></tr></table></figure><p>然后我们要安装用于生成证书的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install gitlab-license</span><br></pre></td></tr></table></figure><span id="more"></span><p>然后，创建文件命名为 <code>license.rb</code> , 并写入如下代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">require &quot;openssl&quot;</span><br><span class="line">require &quot;gitlab/license&quot;</span><br><span class="line"></span><br><span class="line">key_pair = OpenSSL::PKey::RSA.generate(2048)</span><br><span class="line">File.open(&quot;license_key&quot;, &quot;w&quot;) &#123; |f| f.write(key_pair.to_pem) &#125;</span><br><span class="line"></span><br><span class="line">public_key = key_pair.public_key</span><br><span class="line">File.open(&quot;license_key.pub&quot;, &quot;w&quot;) &#123; |f| f.write(public_key.to_pem) &#125;</span><br><span class="line"></span><br><span class="line">private_key = OpenSSL::PKey::RSA.new File.read(&quot;license_key&quot;)</span><br><span class="line">Gitlab::License.encryption_key = private_key</span><br><span class="line"></span><br><span class="line">license = Gitlab::License.new</span><br><span class="line">license.licensee = &#123;</span><br><span class="line">  &quot;Name&quot; =&gt; &quot;none&quot;,</span><br><span class="line">  &quot;Company&quot; =&gt; &quot;none&quot;,</span><br><span class="line">  &quot;Email&quot; =&gt; &quot;example@test.com&quot;,</span><br><span class="line">&#125;</span><br><span class="line">license.starts_at = Date.new(2020, 1, 1) # 开始时间</span><br><span class="line">license.expires_at = Date.new(2050, 1, 1) # 结束时间</span><br><span class="line">license.notify_admins_at = Date.new(2049, 12, 1)</span><br><span class="line">license.notify_users_at = Date.new(2049, 12, 1)</span><br><span class="line">license.block_changes_at = Date.new(2050, 1, 1)</span><br><span class="line">license.restrictions = &#123;</span><br><span class="line">  active_user_count: 10000,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">puts &quot;License:&quot;</span><br><span class="line">puts license</span><br><span class="line"></span><br><span class="line">data = license.export</span><br><span class="line">puts &quot;Exported license:&quot;</span><br><span class="line">puts data</span><br><span class="line">File.open(&quot;GitLabBV.gitlab-license&quot;, &quot;w&quot;) &#123; |f| f.write(data) &#125;</span><br><span class="line"></span><br><span class="line">public_key = OpenSSL::PKey::RSA.new File.read(&quot;license_key.pub&quot;)</span><br><span class="line">Gitlab::License.encryption_key = public_key</span><br><span class="line"></span><br><span class="line">data = File.read(&quot;GitLabBV.gitlab-license&quot;)</span><br><span class="line">$license = Gitlab::License.import(data)</span><br><span class="line"></span><br><span class="line">puts &quot;Imported license:&quot;</span><br><span class="line">puts $license</span><br><span class="line"></span><br><span class="line">unless $license</span><br><span class="line">  raise &quot;The license is invalid.&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if $license.restricted?(:active_user_count)</span><br><span class="line">  active_user_count = 10000</span><br><span class="line">  if active_user_count &gt; $license.restrictions[:active_user_count]</span><br><span class="line">    raise &quot;The active user count exceeds the allowed amount!&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if $license.notify_admins?</span><br><span class="line">  puts &quot;The license is due to expire on #&#123;$license.expires_at&#125;.&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if $license.notify_users?</span><br><span class="line">  puts &quot;The license is due to expire on #&#123;$license.expires_at&#125;.&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">module Gitlab</span><br><span class="line">  class GitAccess</span><br><span class="line">    def check(cmd, changes = nil)</span><br><span class="line">      if $license.block_changes?</span><br><span class="line">        return build_status_object(false, &quot;License expired&quot;)</span><br><span class="line">      end</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">puts &quot;This instance of GitLab Enterprise Edition is licensed to:&quot;</span><br><span class="line">$license.licensee.each do |key, value|</span><br><span class="line">  puts &quot;#&#123;key&#125;: #&#123;value&#125;&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if $license.expired?</span><br><span class="line">  puts &quot;The license expired on #&#123;$license.expires_at&#125;&quot;</span><br><span class="line">elsif $license.will_expire?</span><br><span class="line">  puts &quot;The license will expire on #&#123;$license.expires_at&#125;&quot;</span><br><span class="line">else</span><br><span class="line">  puts &quot;The license will never expire.&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>运行这个代码文件生成证书:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ruby license.rb</span><br><span class="line">$ ls     ## 生成如下三个证书文件</span><br><span class="line">GitLabBV.gitlab-license  license_key  license_key.pub  license.rb</span><br></pre></td></tr></table></figure><p>替换 <code>.license_encryption_key.pub</code> 文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp license_key.pub /opt/gitlab/embedded/service/gitlab-rails/.license_encryption_key.pub</span><br></pre></td></tr></table></figure><p>修改 <code>/opt/gitlab/embedded/service/gitlab-rails/ee/app/models/license.rb</code> 文件, 将 <code>STARTER_PLAN</code> 替换位 <code>ULTIMATE_PLAN</code> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  def plan</span><br><span class="line">-    restricted_attr(:plan).presence || STARTER_PLAN</span><br><span class="line">+    restricted_attr(:plan).presence || ULTIMATE_PLAN</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p>使用 <code>sudo gitlab-ctl restart</code> 重启服务, 然后访问 <code>&lt;gitlab url&gt;/admin/license</code> 并上传证书 <code>GitLabBV.gitlab-license</code> 。</p><p>至此，Gitlab 服务便拥有了全部的功能。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitLab </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CI/CD管道配置</title>
      <link href="/2023/03/08/CI-CD%E7%AE%A1%E9%81%93%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/03/08/CI-CD%E7%AE%A1%E9%81%93%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>上一节中，我们讲述了什么是 Runner 以及如何部署注册 Runner。接着，我们来说说如何定义 CI&#x2F;CD 中的管道的配置。一个管道中，可以包含多个任务(Jobs),然后交由 Runner 去执行。</p></blockquote><p>GitLab CI&#x2F;CD 管道的配置使用的是 YAML 格式的配置文件，在每一个项目中都统一命名位 <code>.gitlab-ci.yml</code> 。</p><p>一个 <code>.gitlab-ci.yml</code> 文件中定义了管道的顺序和结构:</p><ul><li>如何使用 GitLab Runner 执行？</li><li>特定条件下应该做的事情，比如说当处理成功或失败的时候。</li></ul><span id="more"></span><h3 id="管道任务-Pipeline-Jobs"><a href="#管道任务-Pipeline-Jobs" class="headerlink" title="管道任务(Pipeline Jobs)"></a>管道任务(Pipeline Jobs)</h3><p>管道(Pipeline)的配置始于任务(Jobs)。任务是 <code>.gitlab-ci.yml</code> 配置文件中最基础的对象。Jobs 由下面这些特点:</p><ul><li>定义了约束，说明在什么情况下回去执行。</li><li>顶级的元素可以使用任意的名称，但是必须包含 <code>script</code> 子句。</li><li>不限制任务定义的数量。</li></ul><p>下面这个示例展示了任务的定义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">job1:</span><br><span class="line">  script: &quot;echo job1&quot;</span><br><span class="line">job2:</span><br><span class="line">script: &quot;echo job2&quot;</span><br></pre></td></tr></table></figure><p>上面这个示例展示了两个相互隔离的任务，每个任务都执行不同的命令。当然，一行脚本也可以执行多个命令，比如 <code>./configure;make;make install</code> 或者运行一个脚本文件(可以存储在仓库中)。</p><p>Runners 会选择对应的 Jobs 在各自的环境中执行，重要的是，每个 Job 的执行都是独立的。</p><h4 id="CI-Lint"><a href="#CI-Lint" class="headerlink" title="CI Lint"></a>CI Lint</h4><p>GitLab UI 提供了对基于 YAML 的配置文件的验证工具，如下图所示:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1593487968134-001a863e-462b-4415-92d0-7b4aaa9d03a3.png"></p><p>选择 <strong>CI Lint</strong> 可以进行配置文件有效性的验证。</p><h4 id="无效的管道名"><a href="#无效的管道名" class="headerlink" title="无效的管道名"></a>无效的管道名</h4><p>每个任务的名称都必须是唯一的，但也有少数的名称是 GitLab 的保留字符，不可以作为管道的名称:</p><table><thead><tr><th>image</th><th>services</th><th>stages</th></tr></thead><tbody><tr><td>types</td><td>before_script</td><td>after_script</td></tr><tr><td>variables</td><td>cache</td><td>include</td></tr></tbody></table><p>当你使用了特殊的值(比如 <code>true</code> 或者 <code>false</code> )出现验证错误的时候，你可以尝试下面两种写法：</p><ol><li>使用双引号包含它们</li><li>更改他们的来源，比如: <code>/bin/true</code></li></ol><p> </p><h3 id="配置的参数"><a href="#配置的参数" class="headerlink" title="配置的参数"></a>配置的参数</h3><p>配置的参数可以参考附录中的 <strong>管道配置参数表</strong> 。下面针对一些常用的配置做讲解。</p><h4 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h4><p><code>stage</code> 为一组 Jobs 定义了不同的阶段，相同阶段会并发执行。同时，不同的 stage 之间是按照配置文件中定义的顺序执行的。举例说明:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">- build</span><br><span class="line">  - test</span><br><span class="line">  - deploy</span><br><span class="line">  </span><br><span class="line">job0:</span><br><span class="line">stage: build</span><br><span class="line">  script: &quot;echo job0&quot;</span><br><span class="line">  </span><br><span class="line">job1:</span><br><span class="line">stage: build</span><br><span class="line">  script: &quot;echo job1&quot;</span><br><span class="line">  </span><br><span class="line">job2:</span><br><span class="line">stage: test</span><br><span class="line">  script: &quot;echo job2&quot;</span><br><span class="line"> </span><br><span class="line">job3:</span><br><span class="line">stage: deploy</span><br><span class="line">  script: &quot;echo job3&quot;</span><br></pre></td></tr></table></figure><p>根据配置文件对 stages 的定义，会首先执行 build,全部执行成功后执行 test, 全部执行成功后执行 deploy。如示例中，build 由多个 job, 这些 job 会并行执行。</p><p><strong>如果 job 没有指定 stage, 默认是 test.</strong> </p><p>另外，GitLab 还定义了两个特殊的 state, 分别是 <code>.pre</code> 和 <code>.post</code> 。顾名思义， <code>.pre</code> 会在所有的 stage 之前执行，而 <code>.post</code> 会在所有的 stage 之后执行。如下实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stages:</span><br><span class="line">- a</span><br><span class="line">  - b</span><br><span class="line">  </span><br><span class="line">job_pre:</span><br><span class="line">stage: .pre</span><br><span class="line">  script:</span><br><span class="line">  - echo pre</span><br><span class="line"></span><br><span class="line">job_a:</span><br><span class="line">stage: a</span><br><span class="line">  script:</span><br><span class="line">  - echo a</span><br><span class="line"></span><br><span class="line">job_b:</span><br><span class="line">stage: b</span><br><span class="line">  script:</span><br><span class="line">  - echo b</span><br><span class="line">    </span><br><span class="line">job_post:</span><br><span class="line">stage: .post</span><br><span class="line">  script:</span><br><span class="line">    - echo post</span><br></pre></td></tr></table></figure><p>执行这个配置文件中定义的 Pipeline, 我们得到如下的结果:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1593498562628-8ecb3d09-2d15-4c8f-9da1-558030387a25.png"></p><h3 id="CI-x2F-CD-环境变量"><a href="#CI-x2F-CD-环境变量" class="headerlink" title="CI&#x2F;CD 环境变量"></a>CI&#x2F;CD 环境变量</h3><p>环境变量是动态命名的值，它可以影响运行中的进程在操作系统上的行为。</p><p>环境变量是流程运行环境的一部分。比如说，运行的进程可以查询到一个名为 <code>TEMP</code> 的环境变量，从此可知将一些临时文件存储在什么位置。或者为不同的脚本中都需要用到的数据库定义一个名为 <code>URL</code> 的环境变量来标识其地址。</p><p>环境变量对于自定义在任务的执行非常有用。这些变量的使用，可以使得你不用在代码中硬编码它的值。</p><h4 id="预定义的环境变量"><a href="#预定义的环境变量" class="headerlink" title="预定义的环境变量"></a>预定义的环境变量</h4><p>GitLab CI&#x2F;CD 预定义了很多的变量，并在进行运行的过程中主动的赋值，不需要特别的说明和定义。比如说，你可以使用这些变量获得 issue 的编号、用户的名称、分支的名称、管道和提交的 ID，以及更多。</p><p>GitLab 会解析 <code>.gitlab-ci.yml</code>配置文件中的信息，并将其发送给 Runner。这些信息中使用到的环境变量会被暴露在 Runner 运行的本地环境中，然后 Runner 会运行配置文件中执行的脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_variable:</span><br><span class="line">  stage: test</span><br><span class="line">  tags:</span><br><span class="line">    - api</span><br><span class="line">  script:</span><br><span class="line">    - echo $CI_JOB_STAGE</span><br></pre></td></tr></table></figure><p>这个任务执行之后，会有如下输出:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1593424521759-32e026d4-fc93-4241-ae5a-50e35c831d6e.png"></p><p>如果我们要输出所有的环境变量可以使用如下脚本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test_variable:</span><br><span class="line">  stage: test</span><br><span class="line">  tags:</span><br><span class="line">    - api</span><br><span class="line">  script:</span><br><span class="line">    - export</span><br></pre></td></tr></table></figure><p>输出结果如下，部分内容在截图中省略:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1593424753995-ba3f49ff-0f05-486b-b95a-c230593b4604.png"></p><h4 id="自定义的变量"><a href="#自定义的变量" class="headerlink" title="自定义的变量"></a>自定义的变量</h4><p>当你需要自定义变量的时候，可以通过 GitLab 的界面，或是通过 API，或是直接在 <code>.gitlab-ci.yml</code>  配置文件中定义。</p><p>这些自定义的变量可以在 Runner 中的管道运行的任意时刻使用。你也可以手动地在特定的管道中复写变量的值。</p><p>这里由两种类型的变量: 变量和文件。你不能在配置文件 <code>.gitlab-ci.yml</code> 中设置，但是可以通过 GitLab 的 UI 或是通过 API 去设置。</p><p>如何在 <code>.gitlab-ci.yml</code> 中去自定义变量呢？如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">variables:</span><br><span class="line">TEST: &quot;Hello World&quot;</span><br><span class="line">script:</span><br><span class="line">echo &quot;$TEST&quot;</span><br></pre></td></tr></table></figure><p>我们可以使用 GitLab UI 去添加或更新自定义的环境变量:</p><ol><li>进入你的项目: <strong>Settings &gt; CI&#x2F;CD</strong> 的 <strong>Variables</strong> 区块.</li><li>单击 <strong>Add Variable</strong> 按钮。在 <strong>Add Variables</strong>  模块中，填写如下信息:</li></ol><ul><li><strong>Key</strong> : 必须是一行，没有空格，仅允许是字符、数字以及 <code>_</code> 下划线。</li><li><strong>Value</strong> : 没有任何限制。</li><li><strong>Type</strong> : File 或者 Variable。</li><li><strong>Environment scope</strong> : ALL 或者特定的环境。</li><li><strong>Protect variable</strong> (可选): 如果勾选，该变量仅能在受保护的分支或 tags 的管道中使用。</li><li><strong>Mask variable</strong> (可选): 如果勾选，该变量会以掩码的形式记录日志，如果值不满足要求则不会被记录。</li></ul><p>掩码变量的要求如下:</p><ul><li>必须是单行数据。</li><li>必须不少于 8 个字符。</li><li>不能是预定义的环境变量。</li><li>只能包含 Base64 alphabet（RFC4648) 标准中定义的字符。在 GitLab 12.2 以及更新的版本中， <code>@</code> 和 <code>:</code> 是有效的值。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1593484870175-7cbc1055-65fa-47f8-a9a9-9fc56cf93085.png"></p><p>另外，除了项目级别的变量。我们也可以为组设置环境变量(可以通过 GitLab UI 项目组所在的变量设置项)。我们也推荐使用项目组环境变量来存储一些涉密的信息，比如密码、SSH Keys 以及相关的证书。如下图所示:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1593484086638-796be45a-3199-48ff-a49b-5a053ec9eef9.png"></p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="管道配置参数表"><a href="#管道配置参数表" class="headerlink" title="管道配置参数表"></a>管道配置参数表</h4><p>下面这份表格取自官方文档，并不完整，翻译也并不十分准确，仅供参考。完整的文档，请移步<a href="https://docs.gitlab.com/ee/ci/yaml/#gitlab-cicd-pipeline-configuration-reference">官方文档</a>。</p><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>script</td><td>由 Runner 执行的 Shell 脚本</td></tr><tr><td>image</td><td>Docker 的镜像名称</td></tr><tr><td>services</td><td>Docker 的服务镜像，比如 <code>services:name</code> , <code>services:alias</code> , <code>services:entrypoint</code> 或者 <code>services:command</code> .</td></tr><tr><td>before_script</td><td>在任务执行之前执行的脚本</td></tr><tr><td>after_script</td><td>在任务执行之后执行的脚本</td></tr><tr><td>stage</td><td>定义任务的 job stage(默认为 <code>test</code> )</td></tr><tr><td>only</td><td>创建任务的限制，比如 <code>only:refs</code> , <code>only:kubernetes</code> , <code>only:variables</code> , <code>only:changes</code> .</td></tr><tr><td>except</td><td>不创建任务的限制,比如 <code>except:refs</code> , <code>except:kubernetes</code> , <code>except:varibales</code> , <code>except:changes</code> 。</td></tr><tr><td>rules</td><td>评估和确定 obj 的选定属性以及是否创建作业的条件列表。只可以选用 <code>only</code> &#x2F; <code>except</code></td></tr><tr><td>tags</td><td>选择由哪些相同标签的 Runner 运行</td></tr><tr><td>allow_failure</td><td>运行 job 执行失败，失败不会影响提交的状态</td></tr><tr><td>when</td><td>什么时候运行 job。比如 <code>when:manual</code> 以及 <code>when:delayed</code> .</td></tr><tr><td>environment</td><td>job 部署的环境名称。比如 <code>environment:name</code> , <code>environment:url</code> , <code>environment:on_stop</code> ， <code>environment:auto_stop_in</code> 和 <code>environment:action</code> .</td></tr><tr><td>cache</td><td>在后续的运行中被缓存的文件列表。比如: <code>cache:paths</code> , <code>cache:key</code> , <code>cache:untracked</code> 和 <code>cache:policy</code> .</td></tr><tr><td>retry</td><td>定义当发生错误时，可以自动重试的次数和时间。</td></tr><tr><td>timeout</td><td>定义超时时间，优先于项目中超时的设置。</td></tr><tr><td>include</td><td>包含附加的 YAML 任务文件。比如 <code>include:local</code> 、 <code>include:file</code> 、 <code>include:template</code> 、 <code>include:remote</code> .</td></tr><tr><td>variables</td><td>定义任务级别的变量</td></tr><tr><td>resources_group</td><td>限制任务的并发数</td></tr><tr><td>release</td><td>指示 Runner 生成一个 Release 对象。</td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://docs.gitlab.com/ee/README.html">GitLab 官方文档</a></li><li><a href="https://docs.gitlab.com/ee/ci/yaml/README.html#anchors">GitLab CI&#x2F;CD Pipeline Configuration Reference</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitLab </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitlabRunner</title>
      <link href="/2023/03/08/GitlabRunner/"/>
      <url>/2023/03/08/GitlabRunner/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>本文是根据 Gitlab Runner 的官方文档翻译而来。</p></blockquote><h3 id="什么是-Gitlab-Runner"><a href="#什么是-Gitlab-Runner" class="headerlink" title="什么是 Gitlab Runner"></a>什么是 Gitlab Runner</h3><p>GitLab Runner 是一个开源的项目，用于执行 jobs 并将结果返回到 GitLab。它协助 GitLab 完成 CI&#x2F;CD 工作，而前者完成 jobs 的协同工作。</p><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>Gitlab Runner 使用 Go 语言编写，可以单个文件运行，并不依赖于特别的语言环境。</p><p>Gitlab Runner 可以运行再 Linux 、macOS 以及 Windows 等操作系统上。</p><p>如果使用 Docker 安装，应该确保使用最新版本的 Docker。最低版本要求是 v.13.0。</p><span id="more"></span><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Gitlab Runner 拥有如下特性:</p><ul><li><p>允许</p></li><li><p>多个任务并行</p></li><li><p>多个服务可以使用多个 Token</p></li><li><p>根据 Token 限制任务并行的数量</p></li><li><p>任务可以运行</p></li><li><p>在本地</p></li><li><p>使用 Docker 容器</p></li><li><p>使用 Docker 容器基于 SSH 执行任务</p></li><li><p>使用 Dockers 容器再不同的云端和虚拟环境中自动扩容</p></li><li><p>连接到远程的 SSH 服务</p></li><li><p>使用 Go 语言编写，发布位单个的二进制执行文件，并没有其他的环境依赖</p></li><li><p>支持 Bash 以及 Windows 的 PowerShell</p></li><li><p>可以工作在 GNU&#x2F;Linux, macOS 以及 Windows（几乎所有可以运行 Docker 的环境)</p></li><li><p>允许自定义任务的运行环境</p></li><li><p>配置自动重载，无需重启服务</p></li><li><p>简单的安装，支持 Docker、Docker-SSH、Parallels 或者 SSH 运行环境。</p></li><li><p>在 Docker 容器中启用缓存</p></li><li><p>可以在 GNU&#x2F;Linux，macOS 以及 Windows 换进公众简单的安装</p></li><li><p>Embedded Prometheus metrics HTTP server.</p></li><li><p>Referee workers to monitor and pass Prometheus metrics and other job-specific data to GitLab</p></li></ul><h3 id="Gitlab-版本的兼容性"><a href="#Gitlab-版本的兼容性" class="headerlink" title="Gitlab 版本的兼容性"></a>Gitlab 版本的兼容性</h3><p>Gitlab Runner 的版本和 Gitlab 同步。老版本的 Runners 可能在新版本的 GitLab 中依然可以工作，反之亦然。但在有些场景下，一些特性可能无效或者在不同的版本下会有不同的表现。</p><p>在一些小版本的更新之间是保证向后兼容，但是 GitLab 的小版本更新中会引入一些新的特性，这会要求 Runner 和 Gitlab 一样的小版本。</p><h3 id="在-Linux-上安装-Runner"><a href="#在-Linux-上安装-Runner" class="headerlink" title="在 Linux 上安装 Runner"></a>在 Linux 上安装 Runner</h3><p>以 CentOS&#x2F;RedHat 为例, 需要把 <code>&lt;arch&gt;</code> 换成对应服务器的架构，比如 amd64：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git -y  ## 需要先安装 git</span><br><span class="line">$ curl -LJO https://gitlab-runner-downloads.s3.amazonaws.com/latest/rpm/gitlab-runner_&lt;arch&gt;.rpm</span><br><span class="line">$ sudo rpm -i gitlab-runner_&lt;arch&gt;.rpm</span><br><span class="line">$ gitlab-runner --version  ## 输出如下</span><br><span class="line">Version:      13.2.0~beta.125.g88901e5a</span><br><span class="line">Git revision: 88901e5a</span><br><span class="line">Git branch:   refs/pipelines/160517108</span><br><span class="line">GO version:   go1.13.8</span><br><span class="line">Built:        2020-06-26T15:47:33+0000</span><br><span class="line">OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure><p>其他的操作系统或发行版，参考<a href="https://docs.gitlab.com/runner/install/">官方文档</a>。</p><h3 id="Register-Runner"><a href="#Register-Runner" class="headerlink" title="Register Runner"></a>Register Runner</h3><p>完成了 Runner 的安装之后，需要让 GitLab 知道 Runner 的存在，所以需要注册 Runner，使其合法上岗工作。如下操作:</p><ol><li>运行如下命令:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gitlab-runner register</span><br></pre></td></tr></table></figure><ol start="2"><li>输入 GitLab 实例的 URL:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):</span><br><span class="line">http://gitlab.app.com</span><br></pre></td></tr></table></figure><ol start="3"><li>输入注册 Runner 用的 Token：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci token for this runner:</span><br><span class="line">RyYu1xjqHq87PypzJ_GJ   ## 从 ci/cd 设置中获取 Token</span><br></pre></td></tr></table></figure><ol start="4"><li>输入 Runner 的描述:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci description for this runner:</span><br><span class="line">[localhost.localdomain]: test-runner</span><br></pre></td></tr></table></figure><ol start="5"><li>输入与 Runner 关联的 Tags, 也可以稍后再 GitLab 的界面中修改:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci tags for this runner (comma separated):</span><br><span class="line">service, api</span><br></pre></td></tr></table></figure><ol start="6"><li>输入 Runner 执行器的类型:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the executor: docker+machine, docker-ssh+machine, kubernetes, custom, docker, docker-ssh, parallels, virtualbox, shell, ssh:</span><br><span class="line">ssh</span><br></pre></td></tr></table></figure><ol start="7"><li>如果你使用 Docker 作为执行器的类型的话，还需要输入项目中使用的默认镜像:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the Docker image (eg. ruby:2.6):</span><br><span class="line">alpine:latest</span><br></pre></td></tr></table></figure><p>至此，我们的 Runner 就已经注册完成了，我们可以再项目的 CI&#x2F;CD 设置下，看到这个 Runner 的信息:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1593421755235-41a50bb0-4dd4-41a5-8868-253d0816427a.png"></p><p>如果在注册过程中类似出现下面的问题:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Registering runner... failed  runner=2CXtursB status=couldn&#x27;t execute POST against ...Post https://code.dev-test.cn/api/v4/runners: x509: certificate signed by unknown authority</span><br></pre></td></tr></table></figure><p>使用<code>find</code> 命令找到 <code>域名.crt</code> 文件，复制到 <code>/etc/gitlab-runner/certs/</code> 目录中就可以了。这是因为 Gitlab 使用自注册的证书，Gitlab Runner 和 Gitlab 通信需要验证证书。详情参考 <a href="https://docs.gitlab.com/runner/configuration/tls-self-signed.html">官方文档</a> 对这个问题的解释。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="https://docs.gitlab.com/runner/">GitLab Runner Docs</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitLab </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署GitLab</title>
      <link href="/2023/03/08/%E9%83%A8%E7%BD%B2GitLab/"/>
      <url>/2023/03/08/%E9%83%A8%E7%BD%B2GitLab/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>Gitlab 你可以认为是 Github 的高仿产品，是以 Git 为版本管理工具的代码托管平台。它最大的优势就是开源、允许私有化部署。但是相对于其他的开源代码托管平台，它也有占用资源大、且难以分布式部署的问题。这篇文档介绍了如何部署 Gitlab。</p></blockquote><h3 id="Gitlab-介绍"><a href="#Gitlab-介绍" class="headerlink" title="Gitlab 介绍"></a>Gitlab 介绍</h3><p>Gitlab 不仅仅是一个基于 Git 的代码托管平台，更是全流程开发管理平台。集成了项目管理、人员管理、代码管理、CI&#x2F;CD、数据分析等一系列的功能，不可谓不强大。</p><span id="more"></span><p>另外，基于 Gitlab 的二开项目也有很多，比如国内的码云、腾讯工蜂等。在很多互联网公司的项目组，都会使用 Gitlab 作为项目的代码托管、自动化运维平台。</p><h3 id="部署-Gitlab"><a href="#部署-Gitlab" class="headerlink" title="部署 Gitlab"></a>部署 Gitlab</h3><p>Gitlab 的官方文档十分的详细具体，建议也是参考官方文档。之所以写这篇文档，一来是为了完善本系列的文档，二来是作为部署时候的参考，所以相对官方文档为简洁很多。</p><p>Gitlab 占用资源非常多，推荐配置是 2C8M。所以，也不建议水用 Docker 部署它。本文以 CentOS8 为例，安装过程如下。</p><p>首先安装一些必要的组件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y curl policycoreutils openssh-server perl</span><br></pre></td></tr></table></figure><p>如果你需要在将项目开发中的动态，比如某人评审了代码，以邮件的形式发送，那么就需要安装邮件服务:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install postfix</span><br><span class="line">sudo systemctl enable postfix</span><br><span class="line">sudo systemctl start postfix</span><br></pre></td></tr></table></figure><p>添加 Gitlab 的包仓库，并安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><p>配置域名并安装 Gitlab:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo EXTERNAL_URL=&quot;https://code.dev-test.cn&quot; dnf install -y gitlab-ee</span><br></pre></td></tr></table></figure><p>如果没有其他问题的话，就已经安装完成其启动了服务了。之后，需要做的就是在浏览器中访问你设定的域名，因为是第一次访问，所以会跳转到密码重置页面，设定密码后跳转到登录页面。登录即可。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li><a href="https://about.gitlab.com/install/">Gitlab Install Docs</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitLab </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerSwarm部署</title>
      <link href="/2023/03/08/DockerSwarm%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/03/08/DockerSwarm%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><p>在开始 Docker Swarm 的学习之前，我们需要先创建学习所需要的环境。</p><p>有多种方式可以创建环境，其中使用 Docker Machine 创建的成本是最低的，当然也可以使用 Vagrant 创建虚拟环境或者使用云服务器等。</p><p>Docker Machine 可以用来管理本地或远程的多台主机的 Docker 实例。</p><span id="more"></span><h3 id="使用-Docker-Machine"><a href="#使用-Docker-Machine" class="headerlink" title="使用 Docker Machine"></a>使用 Docker Machine</h3><p>首先，我们需要安装 Docker Machine，下面使用 Windows 举例，其他平台参考<a href="https://docs.docker.com/machine/install-machine/">官方文档</a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;</span><br><span class="line">  mkdir -p &quot;$HOME/bin&quot; &amp;&amp;</span><br><span class="line">  curl -L $base/docker-machine-Windows-x86_64.exe &gt; &quot;$HOME/bin/docker-machine.exe&quot; &amp;&amp;</span><br><span class="line">  chmod +x &quot;$HOME/bin/docker-machine.exe&quot;</span><br></pre></td></tr></table></figure><blockquote><p>可能会存在下载失败的情况，需要科学上网，或者使用类似于<code>Free download manager</code>这样的下载软件先行下载，下载之后在命令行中直接执行即可。</p></blockquote><p>在安装完成之后，我们使用如下命令创建基于<code>virtualbox</code>的虚拟机，下面的命令创建了 5 个 Docker 的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox manager1</span><br><span class="line">docker-machine create --driver virtualbox manager2</span><br><span class="line">docker-machine create --driver virtualbox worker1</span><br><span class="line">docker-machine create --driver virtualbox worker2</span><br><span class="line">docker-machine create --driver virtualbox worker3</span><br></pre></td></tr></table></figure><p>安装完成之后，我们可以使用如下的命令来查看已经创建的实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ls</span><br></pre></td></tr></table></figure><p>其输出结果如下图所示:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590139616753-a43137ae-e8b5-437c-ba78-051f2dc74c09.png"></p><h3 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h3><p>从 Docker 1.12 开始，Swarm 已经集成在了 Docker Engine 中，可以使用 <code>Docker Swarm</code>来管理集群。但要注意的是， Docker 集群不仅仅是一个 Docker Swarm 的命令，还包含了 Docker Node 、Docker Server 、Docker Stack、Docker Deploy 以及 Docker Network 等命令。</p><p>我们可以使用如下命令初始化 <code>manager1</code> 为集群的管理主机:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh manager1 docker swarm init </span><br><span class="line">--listen-addr 192.168.99.100:2377 </span><br><span class="line">--advertise-addr 192.168.99.100</span><br></pre></td></tr></table></figure><p>然后分别在 worker 实例中执行加入集群的命令, 注意需要替换当中的 token 部分(参考上一条命令的输出）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh ssh worker1 docker swarm join --token &lt;token&gt; 192.168.99.100:2377</span><br></pre></td></tr></table></figure><p>最后，我们将 manager2 加入集群:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 首先从 manager1 中获取 manager 的加入 token</span><br><span class="line">docker-machine ssh manager1 docker swarm join-token manager</span><br><span class="line">## 然后根据上一条命令输出将 manager2 加入集群,注意替换 token 部分(参考上一条命令的输出)</span><br><span class="line">docker-machine ssh manager2 docker swarm join --token &lt;token&gt; 192.168.99.100:2377</span><br></pre></td></tr></table></figure><p>现在，我们已经成功创建了一个拥有 2 个 manager 以及 3 个 worker 节点的集群环境，可以使用如下命令来查看:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh manager1 docker node ls</span><br></pre></td></tr></table></figure><p>输出如下图所示:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590141184576-092242a5-39ac-4981-a842-e8934a8e5009.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇文档，我们讲述了如何使用 Docker Machine 来创建 Docker Swarm 的测试环境。在下一篇文档中，我们将使用这个创建的环境来为 Docker Swarm 来部署应用。</p><h3 id="附录1-Vagrant-创建集群环境配置文件"><a href="#附录1-Vagrant-创建集群环境配置文件" class="headerlink" title="附录1: Vagrant 创建集群环境配置文件"></a>附录1: Vagrant 创建集群环境配置文件</h3><p>创建 Vagrantfile 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$script = &lt;&lt;-SCRIPT</span><br><span class="line">yum install -y yum-utils vim</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/docker.repo</span><br><span class="line">[docker-ce-stable]</span><br><span class="line">name=Docker CE Stable - x86_64</span><br><span class="line">baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg</span><br><span class="line">EOF</span><br><span class="line">sudo yum install docker -y</span><br><span class="line"></span><br><span class="line">## Install docker compose</span><br><span class="line">curl -sSfl http://downloads.end.wiki/docker-compose-Linux-x86_64 -o docker-compose</span><br><span class="line">chmod +x docker-compose</span><br><span class="line">mv docker-compose /usr/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br><span class="line"></span><br><span class="line">## Start Service</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line">## Modify docker registry image</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">SCRIPT</span><br><span class="line"></span><br><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  config.vm.box = &quot;centos/7&quot;</span><br><span class="line">  config.vm.network &quot;public_network&quot;</span><br><span class="line">config.vm.provision &quot;shell&quot;, inline: $script</span><br><span class="line">  config.vm.define &quot;manager1&quot; do |manager1|</span><br><span class="line">manager1.vm.hostname = &quot;manager1&quot;</span><br><span class="line">end</span><br><span class="line">  config.vm.define &quot;manager2&quot; do |manager2|</span><br><span class="line">manager2.vm.hostname = &quot;manager2&quot;</span><br><span class="line">end</span><br><span class="line">  config.vm.define &quot;worker1&quot; do |worker1|</span><br><span class="line">worker1.vm.hostname = &quot;worker1&quot;</span><br><span class="line">end</span><br><span class="line">  config.vm.define &quot;worker2&quot; do |worker2|</span><br><span class="line">worker2.vm.hostname = &quot;worker2&quot;</span><br><span class="line">end</span><br><span class="line">  config.vm.define &quot;worker3&quot; do |worker3|</span><br><span class="line">worker3.vm.hostname = &quot;worker3&quot;</span><br><span class="line">end</span><br><span class="line">  config.vm.define &quot;dev&quot; do |dev|</span><br><span class="line">dev.vm.hostname = &quot;dev&quot;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后运行 <code>vagrant up</code> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 集群 </tag>
            
            <tag> docker swarm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerSwarm初始化</title>
      <link href="/2023/03/08/DockerSwarm%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/03/08/DockerSwarm%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><p>在上一篇文档中，我们创建了集群的环境，如下图所示，由两台 manager 和 三台 worker 节点组成:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590145628663-deb8cf2b-1d4a-4d8a-99ca-1ae17d5234c9.png"></p><p>集群的部署是为了承载我们的产品(应用)，所以它就像是一口锅，接下来我们要往锅里面下米了。</p><span id="more"></span><h3 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h3><p>默认情况下，Docker Swarm 已经创建了一个名为 ingress 的 overlay 的网络，如下图所示:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590146045421-f59acc75-e18d-4a72-8d36-17870fedc558.png"></p><p>现在，我们需要创建一个自己的基于 overlay 的网络，这种类型的网络可以使得不同的容器之间可以相互通信。</p><p>docker-machine ssh manager1 docker network create –driver overlay swarm_test</p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>之前创建的应用都是没有镜像的，现在我们需要为每一个节点都 PULL 镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh manager1 docker pull nginx:1.18.0-alpine</span><br><span class="line">## 其他的节点也需要 pull 镜像</span><br></pre></td></tr></table></figure><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>接下来，我们来创建一个名为 hello 的应用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 创建服务</span><br><span class="line">docker-machine ssh manager1 docker service create </span><br><span class="line">--replicas 2 --name hello --network=swarm_test nginx:1.18.0-alpine</span><br><span class="line">## 查看服务</span><br><span class="line">docker-machine ssh manager1 docker service ls</span><br></pre></td></tr></table></figure><p>输出结果如下图所示:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590149403134-660478c5-5471-4b8b-85f0-649adf98a1d8.png"></p><p>然后我们来看看这个名为 hello 的服务详情:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh manager1 docker service ps hello</span><br></pre></td></tr></table></figure><p>输出结果如下图:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590149515073-e80def26-caad-4ed5-864a-21d7a9d0e398.png"></p><p>然后我们来看一下运行服务的两个节点的名字:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590150196803-6c4d9b2d-fb96-4683-a7aa-3c4e4a681fbe.png"></p><p>分别如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## hello.1.1dwwaqnallftm6lxn1nx0ahnm</span><br><span class="line">## hello.2.qdpffd8e52pswgxf5auczhtvi</span><br><span class="line">## 使用 ping 来验证两者网络是否联通</span><br><span class="line">docker-machine ssh manager1 docker exec -i hello.1.1dwwaqnallftm6lxn1nx0ahnm \</span><br><span class="line">ping hello.2.qdpffd8e52pswgxf5auczhtvi</span><br><span class="line"></span><br><span class="line">下图证明了两个容器之间是可以相互通信的:</span><br><span class="line"></span><br><span class="line">![](https://cdn.nlark.com/yuque/0/2020/png/502915/1590150391188-55a3f4de-0f1e-44f0-a8b6-9e8fd441432a.png)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这一篇文档中，我们体验了如何使用 Swarm 创建一个分布在多个节点上的应用。但是，截至目前这个应用只是能够在不同节点之间相互通信(ping)而已，还不能够对外提供服务。而这一点，我们将在下一篇文档中予以演示。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 集群 </tag>
            
            <tag> docker swarm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerSwarm</title>
      <link href="/2023/03/08/DockerSwarm/"/>
      <url>/2023/03/08/DockerSwarm/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>Docker Swarm 是一个集群部署 （Cluster Management）和容器编排（Container Orchestration）的工具，可以把一组 Docker 服务器虚拟成一台容器服务并对外提供统一的服务。从 Docker 1.12 版本开始，Docker Swarm 已经被继承到了 Docker Engine 中去，称之为 Swarm Mode。Swarm 这个单词的中文意思为“蜂群”，我们都知道蜜蜂是非常团结的，并且行为也非常一致。</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先，我们需要了解一些 Swarm 的基本概念，包括角色、节点、服务、任务以及堆栈。</p><span id="more"></span><h4 id="什么是角色"><a href="#什么是角色" class="headerlink" title="什么是角色"></a>什么是角色</h4><p>什么是角色呢？在官方文档中给角色的说明如下：“ <strong>A given Docker host can be a manager, a worker, or perform both roles</strong> .”。中文是一个 Host 主机，可以是管理者角色，可以是工作者角色，也可以身兼二职。</p><p>只有两种角色，一种是管理者，它用来管理集群中的工作者。一种是工作者，它是用来运行 Docker 的容器实例的，每个工作者都是独立的，对于其他工作者而言是透明的。一个 Host 主机，可以既是管理者，又是工作者。</p><h4 id="什么是节点"><a href="#什么是节点" class="headerlink" title="什么是节点"></a>什么是节点</h4><p>在官方文档中给节点的定义是：“ <strong>A node is a instance of the Docker engine participating in the swarm</strong> ”。中文是一个节点就是参与到 Swarm 集群中的一个 Docker 的实例。一个集群是由多个节点组成的，每一个节点都是一个 Docker 的容器实例。</p><h4 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h4><p>一个服务可能会包含多个任务，每一个任务都是一个具体的容器。服务是在管理节点中定义的，任务之间都是等同的，所以也称之为副本任务。任务可以在多个工作节点中执行。而服务由两种运行模式：</p><ul><li><code>Replicated Services</code> ：复制服务，选择指定数量的节点来执行副本任务。</li><li><code>Global Services</code> ：全局服务，在每个可用节点上执行副本任务。</li></ul><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>堆栈是一组相互关联的服务，这些服务组成了一个完整的应用。对于一些特别复杂的应用而言，可能会包含多个堆栈。比如，Docker Compose 定义的应用就可以看作是一个运行在单机上的堆栈。</p><h3 id="Swarm-的基本应用"><a href="#Swarm-的基本应用" class="headerlink" title="Swarm 的基本应用"></a>Swarm 的基本应用</h3><p>首先，我们可以使用 Swarm 提供的命令行来创建一个集群:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr=eth0</span><br><span class="line">...省略...下面是 docker 给出的加入这个节点的命令，当中包含了加入所需的 Token</span><br><span class="line">docker swarm join --token SWMTKN-1-68nhc0puztth2y62kfxhgmkdc6owh4g8ztxco2ternd12lg7n9-6p5c37b7r8d2d75enj5kj8n4l 172.16.3.228:2377</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure><p>查看集群的信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br><span class="line">...省略...</span><br><span class="line">Swarm: active</span><br><span class="line">  NodeID: y7qvigl1f8ua6w9txp7tvrozv</span><br><span class="line">  Is Manager: true</span><br><span class="line">  ClusterID: tj64fu7dcwhl99eudntqaahde</span><br><span class="line">  Managers: 1</span><br><span class="line">  Nodes: 3</span><br><span class="line">...省略...</span><br></pre></td></tr></table></figure><p>查看节点信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION</span><br><span class="line">y7qvigl1f8ua6w9txp7tvrozv *   host_a     Ready     Active         Leader           20.10.5</span><br><span class="line">age7isdmzrrsbp0ykjfrsgm5u     host_b     Ready     Active                          20.10.5</span><br><span class="line">d9zr8s2heyj832hxzgwwch9km     host_c     Ready     Active                          20.10.5</span><br></pre></td></tr></table></figure><p>添加一个节点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join-token manager   ## 添加管理节点</span><br><span class="line">$ docker swarm join-token worker  ## 添加工作节点</span><br></pre></td></tr></table></figure><p>移除一个节点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker node rm &lt;NODE_ID&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 若要移除一个管理节点，必须先将其降权为工作节点。若要移除一个工作节点，前提条件必须是它处于不可用状态。如果要强制移除一个处于可用状态的工作节点，需要使用 <code>docker node rm --force &lt;node_name&gt;</code> 。</p></blockquote><p>将节点提权为管理节点或者降权为工作节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker node promote &lt;NODE_ID&gt;</span><br><span class="line">$ docker node demote &lt;NODE_ID&gt;</span><br></pre></td></tr></table></figure><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><p>应用的部署还是使用 docker compose, 单机部署和集群部署命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d    ## 单机部署</span><br><span class="line">$ docker stack deploy     ## 集群部署</span><br></pre></td></tr></table></figure><p>需要注意的是，在集群模式下，Compose 中不再允许指定 Dockerfile，而是应该提前构建好服务所需的镜像。另外，Swarm 之支持 Compose V3 版本。</p><p>部署完成之后，我们就可以管理堆栈和服务了。使用如下命令可以查看栈信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack ls</span><br></pre></td></tr></table></figure><p>使用如下命令可以查看服务信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack services &lt;应用名字&gt;</span><br></pre></td></tr></table></figure><p>查看所有的服务:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br></pre></td></tr></table></figure><p>查看具体的堆栈中的任务:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack ps &lt;应用名称&gt;</span><br></pre></td></tr></table></figure><p>删除堆栈:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack rm app</span><br></pre></td></tr></table></figure><p>删除服务:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service rm &lt;服务名称&gt;...   ## 如果移除了堆栈中所有的服务后，那么堆栈也会被自动移除</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> 集群 </tag>
            
            <tag> docker swarm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerCompose</title>
      <link href="/2023/03/08/DockerCompose/"/>
      <url>/2023/03/08/DockerCompose/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>Docker Compose 是使用 Python 编写的一个容器编排工具，后来被合并到了 Docker 项目中。其主要的作用是，通过配置文件对系列的容器进行构建、编排、管理的操作。</p></blockquote><h3 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker Compose"></a>安装 Docker Compose</h3><p>根据 <a href="https://docs.docker.com/compose/install/">官网的文档</a>，以 Linux 环境为例，安装过程如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 官网地址（不推荐）</span><br><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">## 国内</span><br><span class="line">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><span id="more"></span><p>然后赋予可执行权限:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>注意，Docker Compose 对 Docker 的版本是有要求的，使用最新的版本的 Docker 可以避免这样的问题。</p><p>如果因为网络问题下载困难的话，可以使用下面这个链接:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://downloads.end.wiki/docker-compose-Linux-x86_64</span><br></pre></td></tr></table></figure><p>本文使用如下版本演示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-composer --version ## docker-compose version 1.25.5, build 8a1c60f6</span><br></pre></td></tr></table></figure><h3 id="构建-Wordpress"><a href="#构建-Wordpress" class="headerlink" title="构建 Wordpress"></a>构建 Wordpress</h3><p>使用 Docker Compose 来构建一组容器，只需要一个指定了容器的信息的配置文件即可，一般我们将其命名为  docker-compose.yml 或者 docker-compose.yaml (如果命名为其他的文件名，需要使用 -f 参数来指定)。</p><p>所以，构建 Wordpress 的前提就是创建如下这份配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">db:</span><br><span class="line">  image: mysql:5.7</span><br><span class="line">    volumes:</span><br><span class="line">    - &quot;./.data/db:/var/lib/mysql&quot;</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD: wordpress</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">      MYSQL_USER: wordpress</span><br><span class="line">      MYSQL_PASSWORD: wordpress</span><br><span class="line">      </span><br><span class="line">wordpress:</span><br><span class="line">  depends_on:</span><br><span class="line">    - db</span><br><span class="line">    image: wordpress:latest</span><br><span class="line">    links:</span><br><span class="line">    - db</span><br><span class="line">    ports:</span><br><span class="line">    - &quot;8000:80&quot;</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">    WORDPRESS_DB_HOST: db:3306</span><br><span class="line">      WORDPRESS_DB_PASSWORD: wordpress</span><br></pre></td></tr></table></figure><p>然后在配置文件所在的目录下，运行构建命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d## 启动并在后台运行</span><br></pre></td></tr></table></figure><p>启动之后，我们可以通过 docker container ls 来查看容器的实例:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590385806700-12a5baf0-6a77-4aff-b4f1-3cc665670407.png"></p><p>然后我们可以使用 <code>docker-machine env composer</code> 来查看应用的访问 IP:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590387185895-dccbe815-b0de-4992-86cc-eb56c6f89023.png"></p><p>访问应用:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590387255952-38d5a87a-2028-4029-8db0-3507212b08f8.png"></p><p>如果要查看容器，可以使用 <code>docker-compose ps</code> ; 如果要查看镜像，可以使用 <code>docker-compose images</code> ; 如果要停止并删除应用，可以使用 <code>docker-compose down</code> 命令，容器也会一并删除。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇文档简单描述了如何使用 Docker Composer 来构建 Wordpress 应用，这个案例来源于 <a href="https://docs.docker.com/compose/wordpress/">docker 官方文档</a>。但是，并没有讲述具体的 docker-composer 的命令行如何使用，可以参考 help 帮助文件或者官方的文档。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfilex详解</title>
      <link href="/2023/03/08/Dockerfilex%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/03/08/Dockerfilex%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>这一篇文档详细描述了 Dockerfile 的语法，通过这篇文档可以使用 Dockerfile 创建自己的 Docker 镜像。</p></blockquote><h3 id="使用-FROM-选择基础镜像"><a href="#使用-FROM-选择基础镜像" class="headerlink" title="使用 FROM 选择基础镜像"></a>使用 FROM 选择基础镜像</h3><p>在 Dockerfile 中，我们可以使用<code>FROM</code> 指令来指定基础的镜像，例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br></pre></td></tr></table></figure><p>这个基础的镜像的选择需要遵循下面几个原则:</p><ul><li>官方镜像优于非官方镜像，如果没有官方镜像，尽量选择 Dockerfile 开源的镜像；</li><li>使用固定版本的 tag，而不是每次都是用 latest；</li><li>尽量选择体积小的镜像，推荐使用 alpine 镜像；</li></ul><span id="more"></span><h3 id="通过-RUN-执行指令"><a href="#通过-RUN-执行指令" class="headerlink" title="通过 RUN 执行指令"></a>通过 RUN 执行指令</h3><p>通过 <code>RUN</code> 可以执行一些指令，用来安装软件、配置、清理等操作。但是在编写 <code>RUN</code> 指令的时候，需要主要，我们需要把多条 <code>RUN</code> 合并成一条，这样在镜像中只会生成一层(Layer)。</p><p>压缩前:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN echo &quot;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe&quot; &gt; /etc/apt/sources.lists</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install vim -y</span><br></pre></td></tr></table></figure><p>然后我们来看看压缩指令后的镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN echo &quot;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe&quot; &gt; /etc/apt/sources.lists &amp;&amp; \</span><br><span class="line">    apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install vim -y</span><br></pre></td></tr></table></figure><p>我们来看一下它们之间分层的对比:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker image history test:before</span><br><span class="line">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class="line">941215378f1a   11 minutes ago   /bin/sh -c apt-get install vim -y               68.2MB</span><br><span class="line">e95b3c10769c   11 minutes ago   /bin/sh -c apt-get update                       29.7MB</span><br><span class="line">57e911ab921c   12 minutes ago   /bin/sh -c echo &quot;deb http://mirrors.cloud.al…   67B</span><br><span class="line">c29284518f49   8 days ago       /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line">&lt;missing&gt;      8 days ago       /bin/sh -c #(nop) ADD file:5c3d9d2597e01d1ce…   72.8MB</span><br><span class="line"></span><br><span class="line">$ docker image history test:after</span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">9343b9eb6723   4 minutes ago   /bin/sh -c echo &quot;deb http://mirrors.cloud.al…   97.9MB</span><br><span class="line">c29284518f49   8 days ago      /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line">&lt;missing&gt;      8 days ago      /bin/sh -c #(nop) ADD file:5c3d9d2597e01d1ce…   72.8MB</span><br></pre></td></tr></table></figure><h3 id="文件的复制和目录操作"><a href="#文件的复制和目录操作" class="headerlink" title="文件的复制和目录操作"></a>文件的复制和目录操作</h3><p>复制文件到镜像中，有两个指令可以实现，分别是<code>COPY</code> 和 <code>ADD</code> 。所有的文件都是用 <code>COPY</code> 指令，仅在需要自动解压缩的场景才是用 <code>ADD</code> 指令。</p><p><code>COPY</code> 指令会复制文件本地的权限到镜像中，也就是说复制后的文件拥有源文件一样的文件权限。</p><p><code>ADD</code> 指令，如果复制的是一个 gzip 的压缩文件的时候，会自动去解压缩文件。</p><p>我们可以使用 <code>WORKDIR</code> 指令可切换目录，就类似于 Linux 中的 <code>cd</code> 命令。不同点在于，如果切换的目录不存在，则会自动创建。</p><h3 id="构建参数和环境变量"><a href="#构建参数和环境变量" class="headerlink" title="构建参数和环境变量"></a>构建参数和环境变量</h3><p>在 Dockerfile 中，我们可以通过 <code>ENV</code> 或者 <code>ARG</code> 来创建一个变量。但是两者之间存在很多不同，且容易混淆。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENV PACKAGE=vim</span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y $&#123;PACKAGE&#125;</span><br></pre></td></tr></table></figure><p><code>ARG</code> 的语法也是一样的。那么它们之间有什么区别呢？</p><table><thead><tr><th></th><th>ARG</th><th>ENV</th></tr></thead><tbody><tr><td>生命周期</td><td>只存在于镜像构建阶段</td><td>在镜像构建之后也可以通过环境变量读取</td></tr><tr><td>是否可以动态修改</td><td>可以在构建的时候通过<code>--build-arg</code> 参数动态指定，覆盖 Dockfile 中的参数</td><td>不可以</td></tr></tbody></table><p>它们的关注点不一样，<code>ARG</code> 关注的是在镜像构建阶段，而 <code>ENV</code> 关注的是容器的创建以及运行阶段。</p><h3 id="指定容器启动命令"><a href="#指定容器启动命令" class="headerlink" title="指定容器启动命令"></a>指定容器启动命令</h3><p><code>CMD</code> 可以用来设置容器启动时默认会指定的命令。需要注意下面这些点:</p><ul><li>如果 <code>docker container run</code> 启动容器时指定了其他命令，则 <code>CMD</code> 指令会被忽略；</li><li>如果定了了多个 <code>CMD</code> 指令，则只有最后一个会被执行；</li></ul><p><code>ENTRYPOINT</code> 指令也可以用来指定容器启动命令，那么它和 <code>CMD</code> 指令有什么区别呢？</p><ul><li><code>CMD</code> 指令设置的命令，可以在<code>docker container run</code> 时传入其他命令覆盖，但是<code>ENTRYPOINT</code> 指令设置的命令则不会；</li><li><code>ENTRYPOINT</code> 和 <code>CMD</code> 可以联合使用，<code>ENTRYPOINT</code> 指令设置执行的命令，而 CMD 传递参数；</li></ul><p>在编写命令的时候，支持两种格式，分别为 Shell 格式和 Exec 格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Exec</span><br><span class="line">CMD [&quot;echo&quot;, &quot;hello docker&quot;]</span><br><span class="line"># Shell</span><br><span class="line">CMD echo &quot;Hello $NAME&quot;</span><br><span class="line"># 如果存在变量，则 Exec 模式应该写成如下形式</span><br><span class="line">CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;echo hello $NAME&quot;]</span><br></pre></td></tr></table></figure><h4 id="CMD-示例"><a href="#CMD-示例" class="headerlink" title="CMD 示例"></a>CMD 示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们先来看下面的这个 Dockerfile 示例:</span><br><span class="line"></span><br><span class="line">FROM ubuntu:21.04</span><br><span class="line">CMD [&quot;echo&quot;, &quot;hello docker&quot;]</span><br></pre></td></tr></table></figure><p>我们可以通过命令行中传入的命令来覆盖它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -it test:cmd echo &quot;hello world&quot;</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">$ docker container run --rm -it test:cmd</span><br><span class="line">hello docker</span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT-示例"><a href="#ENTRYPOINT-示例" class="headerlink" title="ENTRYPOINT 示例"></a>ENTRYPOINT 示例</h4><p>接着再来看第二个 Dockerfile 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:21.04</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;]</span><br><span class="line">CMD []</span><br></pre></td></tr></table></figure><p>然后我们运行这个容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -it test:entrypoint echo &quot;Hello World&quot;</span><br><span class="line">echo Hello World</span><br><span class="line"></span><br><span class="line">发现了没有？答应出来的是 `echo Hello World` 而不是 `Hello World`。后面的都被作为参数传递给了 `ENTRYPOINT` 中的 `echo` 命令。</span><br></pre></td></tr></table></figure><h3 id="Dockerfile-最佳实践"><a href="#Dockerfile-最佳实践" class="headerlink" title="Dockerfile 最佳实践"></a>Dockerfile 最佳实践</h3><p>接下来介绍一些编写 Dockerfile 的最佳实践。</p><h4 id="尽可能使用缓存来加快构建速度"><a href="#尽可能使用缓存来加快构建速度" class="headerlink" title="尽可能使用缓存来加快构建速度"></a>尽可能使用缓存来加快构建速度</h4><p>Docker 在构建的时候，会对一些步骤使用缓存，加快再次构建时候的速度。但是要遵循一个规则，如果上一步骤的内容发生了改变，随后的步骤也不会再次使用缓存。</p><p>所以，我们可以把容易改变的内容，写在后面。不容易改变的内容写在前面，以尽可能来利用缓存加快构建。</p><h4 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h4><p>对于一些编译类型的软件，编译所需要的环境就非常巨大，但是运行程序却只需要二进制可执行文件就行了。这种场景就比较适合多阶段构建，最后产生的 Docker 镜像仅仅包含二进制可执行文件所需的运行环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM gcc:9.4 AS builder</span><br><span class="line">COPY hello.c /src/hello.c</span><br><span class="line">WORKDIR /src</span><br><span class="line">RUN gcc --static -o hello hello.c</span><br><span class="line"></span><br><span class="line">FROM alpine:3.13.5</span><br><span class="line">COPY --from=builder /src/hello /src/hello</span><br><span class="line">ENTRYPOINT [&quot;/src/hello&quot;]</span><br></pre></td></tr></table></figure><h4 id="尽可能使用-non-root-用户"><a href="#尽可能使用-non-root-用户" class="headerlink" title="尽可能使用 non-root 用户"></a>尽可能使用 non-root 用户</h4><p>因为 Root 拥有最大的权限，所以最好不用在容器中使用 Root 用户，而是使用非 root 用户。在 Dockerfile 中创建一个用户，并赋予最少的权限，然后使用这个用户去执行我们的应用。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile配置</title>
      <link href="/2023/03/08/Dockerfile%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/03/08/Dockerfile%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>什么是 Dockerfile 呢？它是用来构建 docker 镜像的文件，当中包含了构建镜像所需要的“指令”， 这些指令拥有特定的语法。可以说 Dockerfile 是用来描述我们的镜像的。</p></blockquote><h3 id="上下文-Context"><a href="#上下文-Context" class="headerlink" title="上下文(Context)"></a>上下文(Context)</h3><p>当我们构建 Docker 镜像的时候，Docker 首先会将 Dockerfile 所在的目录中的文件全部发送到守护进程中去。所以你想想看，如果我们把 Dockerfile 放在根目录下，会怎么样？会把整个 Linux 系统所有的文件发送给守护进程……所以，我们在构建镜像的时候，最好为 Dockerfile 文件专门创建一个存放它的文件夹，只把必须要的文件存放在这个文件夹中。 <strong>Dockerfile 所在的文件夹就被称之为是上下文。</strong></p><span id="more"></span><p>如果希望这个文件夹不被包含到上下文中，可以在目录中放入一个名为 <code>.dockerignore</code> 文件，在当中包含一些忽略的文件或者文件夹。这个和 Git 中使用的 <code>.gitignore</code> 文件是一个道理，写法也是一样的。</p><h3 id="指令集合"><a href="#指令集合" class="headerlink" title="指令集合"></a>指令集合</h3><p>Dockerfile 是一组指令组成的，每一个指令都有不同的含义。大致如下表所示:</p><table><thead><tr><th>指令</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td><td><code>FROM ubuntu:14.04</code></td></tr><tr><td>RUN</td><td>运行 Shell 命令,和 CMD 不同的是，可以多次使用。</td><td><code>RUN apt update</code></td></tr><tr><td>CMD</td><td>运行 Shell 命令，一个 Dockerfile 中多行 CMD,只有最后一句有效。如果我们在 <code>docker run</code> 命令后面指定了其他的命令，会覆盖 Dockerfile 中的 CMD 命令。</td><td><code>CMD [&quot;apt&quot;, &quot;install&quot;, &quot;wget&quot;]</code></td></tr><tr><td>LABEL</td><td>设置标签，描述 Image 信息</td><td></td></tr><tr><td>EXPOSE</td><td>暴露端口&#x2F;协议信息，用作描述, 和 <code>docker run -p</code> 参数并不一样，后者是真实暴露出去。</td><td><code>EXPOSE 80</code></td></tr><tr><td>ENV</td><td>设置环境变量</td><td><code>ENV key value</code> 或者 <code>ENV key=value</code></td></tr><tr><td>ADD</td><td>添加外部的文件，如果是压缩包可以解压</td><td></td></tr><tr><td>COPY</td><td>添加外部的文件，不会自动解压</td><td></td></tr><tr><td>ENTRYPOINT</td><td>运行容器的时候，执行的 Shell 命令， 它也会覆盖 CMD  指令，但是它不会被被 <code>docker run</code> 中的指令覆盖。</td><td><code>ENTRYPOINT [&quot;ls&quot;, &quot;-a&quot;]</code></td></tr><tr><td>VOLUME</td><td>设置数据卷</td><td><code>VOLUME /data1 /data2</code> , 创建两个匿名卷</td></tr><tr><td>USER</td><td>设置运行的用户(前提是该用户必须存在)</td><td><code>USER admin</code></td></tr><tr><td>WORKDIR</td><td>设置工作目录，有相对目录和绝对目录之分<code>WORKDIR /</code></td><td></td></tr><tr><td>ARG</td><td>设置构建镜像的参数</td><td>ONBUILD</td></tr><tr><td>STOPSIGNAL</td><td>停止的信号量</td><td></td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td></td></tr><tr><td>SHELL</td><td>Shell</td><td></td></tr></tbody></table><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>我们以一个使用 Python 编写的 Hello World 程序为例，使用 Dockerfile 构建镜像，并在容器中运行。编写<code>hello.py</code> 文件，内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello&quot;)</span><br></pre></td></tr></table></figure><p>然后编写 Dockerfile 文件，内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3</span><br><span class="line">COPY hello.py .</span><br><span class="line">CMD [&quot;python&quot;, &quot;hello.py&quot;]</span><br></pre></td></tr></table></figure><p>使用官方的 Python 镜像，然后将当前目录下的 hello.py 复制到镜像中，当容器运行的时候，执行 <code>python hello.py</code>。</p><p>构建镜像并运行容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker build . -t hello</span><br><span class="line">Successfully built bbf77685d288</span><br><span class="line"></span><br><span class="line">$ docker run bbf</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>你可以通过 <code>-t</code> 指定名称 <code>hello</code> 或者指定名称加上标签<code>hello:v1</code> 。如果你没有指定 tag, 默认就是<code>latest</code>。但是不要以为 <code>latest</code> 指的是最新的标签，这只是一个普通的标签，不会自动更新。</p><h3 id="使用-Commit-来创建镜像"><a href="#使用-Commit-来创建镜像" class="headerlink" title="使用 Commit 来创建镜像"></a>使用 Commit 来创建镜像</h3><p>下面通过 nginx 的官方镜像来演示如何通过 <code>docker commit</code> 来创建一个新的镜像。首先我们需要先创建一个基于官方 nginx 镜像的容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 nginx</span><br><span class="line">ba7f4a6d3120b32de3e060221ff881d05385d520b9cbf6edb7110e431b45b832</span><br><span class="line"></span><br><span class="line">$ docker container exec ba7 sh</span><br><span class="line"></span><br><span class="line">$ docker container exec -it ba7 sh</span><br><span class="line"># echo &quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot; &gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Docker 容器是无状态的，并不会保存我们修改的内容。所以，我们可以使用 <code>commit</code> 来创建一个新的镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d -p 80:80 nginx</span><br><span class="line">35bbaef9854d3ebdea47a786e0aa622f6d036246944a830f4c987d8c17cb6b67</span><br><span class="line"></span><br><span class="line">$ docker container stop 35</span><br><span class="line">35</span><br><span class="line"></span><br><span class="line">$ docker container commit 35 hello:v1</span><br><span class="line">sha256:c28ad860b7a036e1955ab72a0998810a998e86bc4a93f2c97b5de0cd33d87a4a</span><br><span class="line"></span><br><span class="line">$ docker image ls | grep hello</span><br><span class="line">hello        v1        c28ad860b7a0   10 seconds ago   133MB</span><br><span class="line">hello        latest    f3a1eb0a3e1b   25 minutes ago   886MB</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>为了加快镜像的构建速度，我们可以使用阿里云的 Ubuntu 源。为此，需要在 Dockerfile 中增加一句话:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &quot;deb http://mirrors.cloud.aliyuncs.com/ubuntu/ trusty main universe&quot; &gt; /etc/apt/sources.lists</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerRegistry</title>
      <link href="/2023/03/08/DockerRegistry/"/>
      <url>/2023/03/08/DockerRegistry/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>这一篇文档将来讲述有关于 Docker Registry 的相关内容。</p></blockquote><p>Docker 的设计在很大程度上参考了 Git 的思想，Git 是对代码的组织管理，因此有了 Registry 的概念，是存放代码的仓库，一个代码仓库中有一个或多个的代码分支以及版本。而 Docker Registry 也是一样的，是对 Docker Image 的管理，一个 Registry 中包含多个 Image，每个 Image 都会有一个 Tag(标签，和版本是一样的)。</p><p>本文是基于 Docker 官方文档翻译和修改的，原文 <a href="https://docs.docker.com/registry/">Docker Registry</a>。</p><span id="more"></span><h3 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it"></a>What is it</h3><blockquote><p>The Registry is a stateless, highly scalable server side application that stores and lets you distribute Docker images. The Registry is open-source, under the permissive Apache license.</p></blockquote><p>Registry 是一个无状态、高度可扩展的服务端的应用程度，你可以使用它来存储、分发你的 Docker 镜像。Registry 是开源的，其基于 Apache 许可协议。</p><h3 id="Why-use-it"><a href="#Why-use-it" class="headerlink" title="Why use it"></a>Why use it</h3><p>You should use the Registry if you want to:</p><ul><li>tightly control where your images are being stored</li><li>fully own your images distribution pipeline</li><li>integrate image storage and distribution tightly into your in-house development workflow</li></ul><p>为什么要使用它呢？简单来说，就是在你需要控制镜像的存储、分发在你的内部环境，而不愿与所有人的分享的时候。</p><h3 id="Basic-commands"><a href="#Basic-commands" class="headerlink" title="Basic commands"></a>Basic commands</h3><p>Docker 的命令遵循 Unix 的一般规范，支持短命令(使用 <code>-</code> 加上一个字母)、长命令(使用 <code>--</code> 加上一个完整的单词)、组合命令(多个短命令可以组成组合命令，比如 <code>docker container ls -aq</code> )。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Start your registry. 创建属于你自己的仓库: </span><br><span class="line"></span><br><span class="line">docker-machine create --driver virtualbox registry  ## 创建一台基于 virtualbox 的虚拟机，命名为 registry</span><br><span class="line">docker run -d -p 5000:5000 --name registry registry:latest  ## 拉取最新的 registry 的容器镜像并在后台运行，其映射端口为 5000</span><br></pre></td></tr></table></figure><p>Pull Or Build Some image from the hub. 从 Hub 中拉取或创建一些镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure><p>Tag the image so that it points to your registry. 为你的镜像打上标记以及指明 Registry 仓库:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag ubuntu localhost:5000/myfirstimage</span><br></pre></td></tr></table></figure><p>Push it. 发布你的镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push localhost:5000/myfirstimage</span><br></pre></td></tr></table></figure><p>Pull it back. 从仓库中拉取你的镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push localhost:5000/myfirstimage</span><br></pre></td></tr></table></figure><p>Now stop your registry and remove data. 现在暂停你的仓库服务并移除所有的数据:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop registry &amp;&amp; docker container rm -v registry</span><br></pre></td></tr></table></figure><p>从私有仓库 Pull 镜像的时候，可能会出现如下错误提示:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590569548036-da4cdd3a-8d17-4c4a-a213-18e169505f0f.png"></p><p>解决这个问题有两个办法，分别是配置 Docker 的 insecure-registries 配置项或者配置 SSL 证书。这里介绍第一种, 编辑 <code>/etc/docker/deamon.json</code> 配置文件，将仓库的地址加入其中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.99.105:5000&quot;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重新启动 Docker 服务以使配置生效:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/docker restart ## sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>本文描述了什么是 Docker Registry，以及如何基于 Docker Registry 创建属于自己的仓库服务。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络管理</title>
      <link href="/2023/03/08/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/08/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>在这一篇文档中，你讲看到 Docker 中如何进行网络的管理，包括网络的类型以及它们的应用。</p></blockquote><h3 id="默认的网络类型"><a href="#默认的网络类型" class="headerlink" title="默认的网络类型"></a>默认的网络类型</h3><p>当我们安装好 Docker 之后，就已经创建了三个默认的网络，可以使用如下命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">dff28c734f9f   bridge    bridge    local</span><br><span class="line">1e7467b6d95b   host      host      local</span><br><span class="line">2ea4d9c5d1fb   none      null      local</span><br></pre></td></tr></table></figure><span id="more"></span><p>下面我们分别来介绍和演示这三种网络类型。我们可以通过如下命令来查看网络的详细信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect bridge | grep Name ## 过滤掉除名字外其他的内容</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br></pre></td></tr></table></figure><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>Bridge 是桥接网络, 默认情况下，我们创建的容器如果没有指定网络（使用 <code>--network</code> 参数指定）使用的就是桥接网络。<strong>桥接网络的特点是，容器之间是可以相互通信的，但是容器和主机是不能联通的，需要通过 iptables 来实现端口映射。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name test_1 ubuntu:16.04 /bin/sh## 创建第一个容器</span><br><span class="line">$ docker run -itd --name test_2 --network bridge ubuntu:16.04 /bin/sh  ## 创建第二个容器</span><br></pre></td></tr></table></figure><p>然后我们分别查看两个容器的 IP 以及子网:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect test_1 | grep -E &quot;IPAddress|Gateway|IPPrefixLen&quot; | head -n4</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">$ docker inspect test_2 | grep -E &quot;IPAddress|Gateway|IPPrefixLen&quot; | head -n4</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br></pre></td></tr></table></figure><p>我们看到这两个容器都在同一个网段内，你可以使用 <code>docker attach</code> 来验证网络是否互联:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 默认情况下，这个 Ubuntu:16.04 没有安装 ping，安装如下</span><br><span class="line">apt update</span><br><span class="line"></span><br><span class="line">apt install iputils-ping</span><br><span class="line">## 安装完成之后</span><br><span class="line">ping 172.12.0.3 ## test_2 容器也是一样的过程</span><br></pre></td></tr></table></figure><p>我们前面也说到了，如果要在主机上访问容器中的服务，是通过 iptables 实现端口映射的。我们来做一个实验，创建一个 Apache 的容器，Dockerfile 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER JinZhiSu/happy@hacking.icu</span><br><span class="line">ENV DEBIAN_FRONTEND noninteractive</span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get -yqq install dialog &amp;&amp; apt-get install -yqq apache2</span><br><span class="line">CMD [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure><p>然后构建镜像，并创建容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t apache:1.0 .</span><br><span class="line">docker run -d -p 10001:80 --name web apache:1.0</span><br></pre></td></tr></table></figure><p>然后查看 iptable 的规则，你可以看到 <code>DNAT</code> 的规则发生了变化:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t nat -nvL</span><br><span class="line">## ...省略部分内容...</span><br><span class="line">5   320 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:10001 to:172.17.0.2:80</span><br><span class="line">## ...省略部分内容...</span><br></pre></td></tr></table></figure><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>默认的 bridge 网络，每次重启容器，容器的 IP 都会发生变化。对于默认的 bridge 网络，不能在启动容器的时候指定 IP。为了达到这个目的，我们可以使用自定义网络。在旧版的 Docker 中，通常通过 <code>--link</code> 参数来实现容器互联，但是现在已经不推荐这么做了，所以就不讲了。</p><p>首先要创建一个自定义的网路，设定驱动为 <code>bridge</code> 桥接模式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network create my-net</span><br><span class="line">9095a08fdf7d071da19861467665d4d323d5696baa5b9cf416c0ca591499e3f4</span><br><span class="line">$ sudo docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">9095a08fdf7d   my-net    bridge    local## 我们自己创建的网络</span><br></pre></td></tr></table></figure><p>然后创建两个容器，全部指定网络为刚才我们创建的这个自定义网络:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -itd --name test3 --network my-net ubuntu:14.04 /bin/sh</span><br><span class="line">$ sudo docker run -itd --name test4 --network my-net ubuntu:14.04 /bin/sh</span><br><span class="line">$ sudo docker attach test3</span><br><span class="line"># ping test4## 可以使用容器名字替换 IP</span><br><span class="line">PING test4 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from test4.my-net (172.18.0.3): icmp_seq=1 ttl=64 time=0.106 ms## 证明容器之间可以相互联通</span><br></pre></td></tr></table></figure><h3 id="Host-网络"><a href="#Host-网络" class="headerlink" title="Host 网络"></a>Host 网络</h3><p>Host 网络指的是容器和主机可以互联。举个例子来说, 我们可以通过容器采用 Host 网络实现，将容器中的服务端口直接注册到本地，就如同本地创建了这个服务一般:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --name web -d --network host nginx</span><br><span class="line">3bab7527ac3855dcd13bfb4d9e2f21dce1ba6f48883c54d5a99f4d10e6dfb42c</span><br><span class="line"></span><br><span class="line">$ curl localhost</span><br><span class="line">......输出省略</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">......输出省略</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="None-网络"><a href="#None-网络" class="headerlink" title="None 网络"></a>None 网络</h3><p>none 网络指的是在容器中不提供其他网络接口。none 网络的容器创建之后还可以自己 connect 一个网络，比如使用 <code>docker network connect bridge 容器名</code> 可以将这个容器加入到 bridge 网络中。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储管理</title>
      <link href="/2023/03/08/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/08/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>这篇文档描述了在 Docker 中管理数据的几种方式。包括如何使用 volumes, 使用 bind mounts, 使用 tmpfs, 数据卷容器，数据卷的备份以及恢复等。</p></blockquote><h3 id="数据保存在容器中"><a href="#数据保存在容器中" class="headerlink" title="数据保存在容器中"></a>数据保存在容器中</h3><p>直到目前为止，我们的数据都直接存储在 Docker 的容器当中，容器本质上就是一个进程，存储在容器中也就是存储在内存中，这会存在一些问题:</p><ul><li>当容器不再运行的时候，我们无法使用数据。</li><li>当容器被删除的时候，数据也会跟着消失。</li><li>数据保存在容器的可写层中，我们无法轻松的把数据迁移到其他地方。</li></ul><p>所以，我们需要考虑数据如何持久化的问题。</p><span id="more"></span><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Docker 提供了卷(Volumes)、挂载(Bind Mounts)、临时文件系统(Tmpfs) 这几种方式，大多数情况下，我们只会使用卷。</p><ul><li>Volumes: 卷存储在 Docker 管理的主机文件系统中，具体的目录是 <code>/var/lib/docker/volumes</code> ，完全由 Docker 管理。</li><li>Bind Mounts: 绑定挂载，可以将主机上的文件或者目录挂载到容器中。</li><li>Tmpfs: 仅存储在主机系统的内存中，而不会写入主机的文件系统。</li></ul><h4 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h4><p>我们可以使用如下命令来创建一个卷:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create  ## 会随机生成一个 Volume 的名字</span><br><span class="line">c4dbf70166cc480b2f7e6b77da8ca0747395eba8dd1262456c9003842713ab5f    ## Volume 的名字</span><br></pre></td></tr></table></figure><p>查看当前已经创建的 Volume：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               c4dbf70166cc480b2f7e6b77da8ca0747395eba8dd1262456c9003842713ab5f</span><br></pre></td></tr></table></figure><p>这种随机命名的卷，也称之为 <strong>匿名卷</strong> 。我们也可以在创建 Volume 的时候，手动指定名称:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create mysql_data</span><br><span class="line">mysql_data</span><br><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               c4dbf70166cc480b2f7e6b77da8ca0747395eba8dd1262456c9003842713ab5f</span><br><span class="line">local               mysql_data</span><br></pre></td></tr></table></figure><p>创建了一个 Volume 之后，我们就可以在启动一个容器的时候，指定这个数据卷。当我们运行 <code>docker run</code> 命令的时候，就可以使用 <code>-v</code> 或者 <code>--volume</code> 参数来指定卷，被指定的卷可以和容器中的目录或文件做映射(即你访问容器中的该目录就等于是访问主机中的卷, 实际上，该卷是位于主机中的):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v [host-dir:]container-dir[:options]</span><br></pre></td></tr></table></figure><p>命令的格式就如上所示，当中的参数我们分别来讲:</p><ul><li><code>host-dir</code> ：指定主机当中的卷，这是可以省略的，如果省略的话，就会创建一个匿名卷，如果指定的是主机上的目录的话，就需要使用绝对路径。</li><li><code>container-dir</code> ：这个指的是挂载到容器上的目录或文件。</li><li><code>options</code> ：这个选项的取值范围为 <code>[rw|ro,][z|Z]</code> ，其中 <code>rw</code> 表示可读可写， <code>ro</code> 表示只读。这两种模式可以搭配 <code>[z|Z]</code> ，使用 <code>,</code>  分隔，其中 <code>z</code> 表示该卷可以被多个容器使用，而 <code>Z</code> 表示这个卷只能被当前的容器使用。</li></ul><p>在实际的使用过程中，我们更推荐使用 <code>--mount</code> 选项来指定卷, 格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --mount type=volume,src=named_volume,target=container-path,readonly=true</span><br></pre></td></tr></table></figure><p>命令的格式就如上所示，当中的参数我们分别来讲:</p><ul><li><code>type</code> ，挂载的类型，取值范围为 <code>bind</code> 、 <code>volume</code> 、 <code>tmpfs</code> 。</li><li><code>source</code> ，指的是主机管理的命名卷，也可以写成 <code>src</code> 。</li><li><code>dst</code>  ，也可以写成 <code>destination</code> 、 <code>target</code> 。卷在容器中映射的文件或者目录。</li><li><code>readonly</code> ， 取值范围为 <code>true</code> 或者 <code>false</code> ，卷是否只读。</li></ul><p>下面我们创建一个 Volume 并创建容器使用它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create test_volume## 创建一个卷</span><br><span class="line">test_volume</span><br><span class="line">## 创建容器并指定卷</span><br><span class="line">$ docker container run -it --name test_contianer --mount type=volume,src=test_volume,dst=/volume --rm ubuntu /bin/sh</span><br><span class="line"># cd /voume     ## 可以进入卷，当我们在这个容器中往当中写入内容的时候，会同步到主机管理的卷中，不会随着容器删除而消失</span><br></pre></td></tr></table></figure><h4 id="Bind-Mounts"><a href="#Bind-Mounts" class="headerlink" title="Bind Mounts"></a>Bind Mounts</h4><p>Bind Mounts 这种形式就是将主机上的目录直接绑定到容器中去，实现在容器中对主机目录的读写。我们来实验一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run -it --mount type=bind,src=/home/vagrant/host-dir,dst=/docker-dir --name test2 --rm ubuntu /bin/sh</span><br><span class="line"># cd /docker-dir</span><br><span class="line"># touch test1## 在容器中创建文件</span><br><span class="line"># exit</span><br><span class="line">$ ls## 主机中也已经存在该文件了</span><br><span class="line">test1</span><br></pre></td></tr></table></figure><h4 id="Tmpfs"><a href="#Tmpfs" class="headerlink" title="Tmpfs"></a>Tmpfs</h4><p>最后，我们演示一下使用 Tmpfs 方式，比上面两种更简单一些。当容器停止的时候，响应的数据就会被移除:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --munt type=tmpfs,dst=/test --name test --rm ubuntu /bin/sh</span><br></pre></td></tr></table></figure><h3 id="使用数据卷容器共享数据"><a href="#使用数据卷容器共享数据" class="headerlink" title="使用数据卷容器共享数据"></a>使用数据卷容器共享数据</h3><p>如果容器之间需要共享一些持续更新的数据，最简单的方式就是使用用户数据卷容器。其他的容器可以挂载这个容器实现数据共享，这个挂载的数据卷的容器就叫做数据卷容器。你可以理解成是把数据卷使用容器的方式启动。</p><p>我们可以在执行 <code>docker run</code> 的时候，使用 <code>--volumes-from</code> 参数来指定数据卷容器。下面的示例中，我们创建了一个数据卷容器以及两个普通的容器，这两个普通的容器都指向了数据卷容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volume create vdata## 创建数据卷</span><br><span class="line">docker container run -it -v vdata:/vdata --name data_1 ubuntu /bin/bash  ## 创建数据卷容器</span><br><span class="line">docker container run -it --volumes-from data_1 --name data_2 ubuntu /bin/bash   ## 将 data_2 指向数据卷容器 1</span><br><span class="line">docker container run -it --volumes-from data_1 --name data_3 ubuntu /bin/bash   ## 将 data_3 指向数据卷容器 2</span><br></pre></td></tr></table></figure><p>这样我们就实现了两个容器共享一个数据卷容器。</p><h4 id="备份数据卷容器中的数据"><a href="#备份数据卷容器中的数据" class="headerlink" title="备份数据卷容器中的数据"></a>备份数据卷容器中的数据</h4><p>数据存储于数据卷中，如果我们想要备份它，可以采用创建备份容器的方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --volumes-from data_1 -v /home/vagrant/backup:/backup ubuntu tar cvf /backup/backup.tar /vdata/</span><br><span class="line">/vdata/</span><br><span class="line">/vdata/test.t</span><br><span class="line">tar: Removing leading `/` from member names</span><br><span class="line">$ ls /home/vagrant/backup/</span><br><span class="line">backup.tar## 备份的文件</span><br></pre></td></tr></table></figure><p>那么如何恢复文件呢？应该也是一样的道理吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --volumes-from data_1 -v /home/vagrant/backup:/backup ubuntu tar xvf /backup/backup.tar -C /</span><br><span class="line">vdata/</span><br><span class="line">vdata/test.t</span><br></pre></td></tr></table></figure><p>启动一个新的恢复容器，然后将数据解压到 <code>vdata</code> 的上一级目录中去。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>镜像管理</title>
      <link href="/2023/03/08/%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/08/%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><p>什么是镜像呢？镜像就是一个模版，用来创建容器的模板。当我们执行“docker run”的时候，会首先查找本地是否存在对应的镜像，如果不存在则会在 Docker Registry 上查找下载。Docker 的镜像是增量的修改，每次创建新的镜像都会在老的镜像上面构建一个增量的层(Layer)，有利于层的复用，减少镜像的体积，利于网络传输。</p><p>我们先来说几个镜像相关的概念，比如说 Repository 是镜像存储的位置，名为仓库。而 Registry 是镜像仓库的注册服务器，每个仓库中都包含了很多的镜像。每个镜像还会又一个 Tag（标签), 这个 Tag 我们一般会标记为镜像的版本，这点就 Git 中的版本的概念是一致的。比如说 <code>Ubuntu:14.04</code> ，其中 <code>Ubuntu</code> 就是镜像的名字，而 <code>14.04</code> 是它的 Tag，也是它的版本。</p><span id="more"></span><h3 id="镜像的基本操作"><a href="#镜像的基本操作" class="headerlink" title="镜像的基本操作"></a>镜像的基本操作</h3><p>然后我们可以使用 <code>docker image ls</code> 命令来查看本地的镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   14 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>指定镜像的名称也是可以的， 指定版本可以使用 <code>镜像名字:版本</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls hello-world</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   14 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>如果要查看一个镜像的详细信息，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect hello-world | grep Id   ## 输出太多的内容，过滤一下</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b&quot;,</span><br></pre></td></tr></table></figure><p>联网搜索镜像使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker search ubuntu | head -n2  ## 输出太多的内容，过滤一下</span><br><span class="line">NAME                                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">ubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   11992     [OK]</span><br></pre></td></tr></table></figure><p>拉取镜像使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker image pull ubuntu:14.04</span><br><span class="line">14.04: Pulling from library/ubuntu</span><br><span class="line">2e6e20c8e2e6: Pull complete</span><br><span class="line">## ...省略部分输出内容...</span><br></pre></td></tr></table></figure><p>对于拉取下来的镜像，默认的存储路径如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ls /var/lib/docker/overlay2  ## 省略输出内容</span><br></pre></td></tr></table></figure><h3 id="镜像的创建"><a href="#镜像的创建" class="headerlink" title="镜像的创建"></a>镜像的创建</h3><p>创建新的镜像有两种方式，一种方式是修改已经创建的容器，在这个基础上创建镜像，另一种方式是使用 Dockerfile 文件来创建镜像。在生产环境下，我们推荐使用第二种方式来创建镜像。</p><h4 id="修改已经存在的容器创建镜像"><a href="#修改已经存在的容器创建镜像" class="headerlink" title="修改已经存在的容器创建镜像"></a>修改已经存在的容器创建镜像</h4><p>如果我们要创建一个新的镜像，可以基于一个已经存在的镜像。用它来创建一个容器，然后在容器中进行修改，之后提交到一个新的镜像中去:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -it --name test busybox /bin/sh</span><br><span class="line">## ...省略部分输出内容...</span><br><span class="line">/ # touch test1 test2## 在容器中创建两个新的文件</span><br><span class="line">## 使用 CTRL+P 以及 CTRL+Q 退出容器</span><br></pre></td></tr></table></figure><p>在退出容器之后，我们使用 <code>docker container commit</code> 命令来创建一个新的镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container commit test new_test## 由当前运行着的 test 容器创建出一个新的镜像，名为 new_test</span><br><span class="line">sha256:6c88835118a947a1d2af0313157bb0a55204299f9ff4096297fefabe18a987e2</span><br></pre></td></tr></table></figure><p>但是这种方法并不建议在生产环境中使用，因为这样创建出来的镜像非常难以维护。我们推荐使用 Dockerfile 的方式来创建一个新的镜像。</p><h4 id="使用-Dockerfile-创建镜像"><a href="#使用-Dockerfile-创建镜像" class="headerlink" title="使用 Dockerfile 创建镜像"></a>使用 Dockerfile 创建镜像</h4><p>Dockerfile 文件是一个用来描述镜像的创建过程的文件，换句话说我们通过 Dockerfile 这个文件告诉 Docker，我们这个镜像的一些基本信息，如何创建这个镜像，创建这个镜像之后要做什么事情。怎么告诉呢？通过预定义的一些指令,指令的格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTRUCTION arguments   ## 它是有指令和参数构成的，就和 Linux 下的命令是一样的逻辑</span><br></pre></td></tr></table></figure><p>那么一个基本的 Dockerfile 都包含那些内容呢？其实这个问题的答案也就是我们之前提的几个问题的答案，如何创建这个镜像？创建之后要干什么？</p><ol><li>基础镜像：我们大概不会从零创建一个镜像，我们需要一个以某个镜像为基础，在这个基础上增加我们自己的内容，使用 <code>FROM</code> 指令来指定。</li><li>维护者信息: 这个镜像是谁维护的，除了问题找谁？通过 <code>MAINTAINER</code> 指令可以指定维护者的名字和邮箱。</li><li>镜像操作命令：我们要在基础镜像上进行那些修改？是创建文件还是安装服务器环境或者进行特殊的配置？常用的命令是 <code>RUN</code> ，运行 Shell 的命令或脚本。</li><li>容器的启动命令：当容器启动的时候需要执行那些命令或脚本？使用指令 <code>CMD</code> 或者 <code>ENTRYPOINT</code> 。</li></ol><p>说了那么多，我们来创建一个 Dockerfile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER JinZhiSu/happy@hacking.icu</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install apache2</span><br><span class="line">CMD [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]## CMD 只能出现一次，如果出现多次，只会执行最后一条命令</span><br></pre></td></tr></table></figure><p>通过短短 4 行，我们就创建了一个新的 Dockerfile, 也就创建了一个新的镜像。但是，我们还需要让这个 Dockerfile 通过 docker 成为真正的镜像文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build .## . 表示当前目录，会自动查找当前目录下的 Dockerfile, 当然我们也可以使用 -t 参数来指定具体的 Dockerfile 文件</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM ubuntu:14.04</span><br><span class="line"># ...省略更多输出...</span><br></pre></td></tr></table></figure><p>然后我们可以通过 <code>docker image ls</code> 命令来查看刚刚创建的 Docker 镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls                                                                    [15:42:04]</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">&lt;none&gt;                          &lt;none&gt;              2d59468593eb        About a minute ago   197MB</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>删除一个镜像可以使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm 956## 不能删除已经被容器使用的镜像</span><br><span class="line">956</span><br><span class="line">$ docker image rm 2d5</span><br><span class="line">Deleted: sha256:2d59468593ebb585aa82cd02989cada50c3145979858801555115c358a1af8d5</span><br></pre></td></tr></table></figure><p>如果要批量删除没有使用的镜像，可以如下示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><h3 id="镜像的导入和导出"><a href="#镜像的导入和导出" class="headerlink" title="镜像的导入和导出"></a>镜像的导入和导出</h3><p>当我们在内网或者其他特殊的网络环境下，无法连接到 Registry 的时候，就可以通过将已经存在的镜像导出到存储设备中，然后在对应的环境中部署。</p><p>镜像的导出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED      SIZE</span><br><span class="line">ubuntu       latest    c29284518f49   7 days ago   72.8MB</span><br><span class="line">$ docker image save ubuntu -o ubuntu.image</span><br><span class="line">$ ls</span><br><span class="line">ubuntu.image</span><br></pre></td></tr></table></figure><p>导入镜像如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image load -i ./ubuntu.image</span><br><span class="line">a70daca533d0: Loading layer [==================================================&gt;]  75.16MB/75.16MB</span><br><span class="line">Loaded image: ubuntu:latest</span><br></pre></td></tr></table></figure><h3 id="运行-MySQL-容器"><a href="#运行-MySQL-容器" class="headerlink" title="运行 MySQL 容器"></a>运行 MySQL 容器</h3><p>关于 MySQL 的镜像，我们可以参考<a href="https://hub.docker.com/_/mysql">官方文档</a>。如果环境变量比较多，我们可以创建一个文件用来保存，而不是通过命令的方式指定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_ROOT_PASSWORD=root</span><br><span class="line">MYSQL_DATABASE=test</span><br><span class="line">MYSQL_USER=shiyanlou</span><br><span class="line">MYSQL_PASSWORD=Xbcd20198$</span><br></pre></td></tr></table></figure><p>然后我们来运行 MySQL 的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -d --env-file ./env_file -p 3306:3306 mysql:5.5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器管理</title>
      <link href="/2021/03/08/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2021/03/08/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>这一篇文档描述了容器管理的一些命令，比如启动容器、退出容器、关闭容器、删除容器等。容器的管理使用 <code>docker contaner</code> 命令。</p></blockquote><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>我们从 Hello World 开始，如何创建一个容器呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure><p><code>docker run</code> 是一条复合命令，严格来说并不是创建容器的命令。创建容器使用 <code>docker create</code> 命令，在说它之前先来说说 <code>docker run</code> 都做了什么事情？</p><ol><li>检查本地是否存在指定的镜像</li><li>如果不存在指定的镜像，则连接 Dcoker Registry 下载</li><li>下载之后创建容器</li><li>创建容器之后运行容器, 启动容器可以用 <code>docker container start</code> 命令</li></ol><span id="more"></span><p><code>docker run</code> 有一些常用的参数，如下:</p><ul><li><code>-i</code> 或者 <code>--interactive</code> : 交互模式</li><li><code>-t</code> 或者 <code>--tty</code> ：分配一个 <code>pseduo-TTY</code> ，伪终端</li><li><code>--rm</code> ：在容器退出后自动移除</li><li><code>-p</code> ：将容器的端口映射到主机</li><li><code>-v</code> 或 <code>--volume</code> ：指定数据卷</li></ul><p>我们也可以在后面加上容器运行后要执行的 Shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run busybox echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>如果我们希望容器保持运行，可以指定 <code>-it</code> 参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -i -t ubuntu /bin/bash</span><br><span class="line">root@14b5c7524f2f: /#</span><br></pre></td></tr></table></figure><p>默认情况下，主机名 <code>14b5c7524f2f</code> 是容器的 ID。那么我们如何退出容器呢？可以在终端输入 <code>exit</code> ，然后使用如下命令观察容器的状态:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a # 你可以看到状态为 Exited</span><br></pre></td></tr></table></figure><p>我们也可以指定 <code>-d</code> 参数，让容器在后台运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run -itd ubuntu /bin/bash</span><br><span class="line">## 观察容器状态，应该为 Up</span><br><span class="line">docker container ls## 如果不加上 -a, 只显示运行状态的容器</span><br></pre></td></tr></table></figure><p>然后，我们再来看看 <code>docker create</code> 命令，相对于 <code>docker run</code> 只会创建容器，但是不会运行。执行后返回容器的 ID:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container create --name shiyanlou \          ## 指定容器名称</span><br><span class="line">--hostname shiyanlou \          ## 指定 Hostname</span><br><span class="line">  --mac-address 00:01:02:03:04:05 \          ## 指定 mac 地址</span><br><span class="line">  --ulimit nproc=1024:2048 -it ubuntu /bin/bash## 指定 ulimit</span><br><span class="line">## 观察容器状态</span><br><span class="line">docker container ls  ## 应该是 Created</span><br></pre></td></tr></table></figure><p>查看 docker 容器的详细信息可以使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect [容器名称|容器ID]</span><br></pre></td></tr></table></figure><h3 id="容器的的运行模式"><a href="#容器的的运行模式" class="headerlink" title="容器的的运行模式"></a>容器的的运行模式</h3><p>容器有三种运行模式，分别是 <code>attached</code> 模式、<code>detached</code> 模式以及可交互模式。下文分别予以介绍。</p><h4 id="Attached-模式"><a href="#Attached-模式" class="headerlink" title="Attached 模式"></a>Attached 模式</h4><p>当你使用<code>docker container run</code> 命令来运行一个容器之后，容器就处于 <code>attached</code> 模式，容器中的输出会输出到当前的输出中，同样当前环境中信号的输入也会传递到容器中去。比如你使用<code>CTRL+C</code> ，信号也会传递给容器，从而停止容器进程的运行。</p><blockquote><p>注意: Windows 下并不支持完整的 Attached 模式，并不支持信号向容器的传递。所以即是你使用<code>CTRL+C</code>，也不会终止容器进程的运行。</p></blockquote><h4 id="Detached-模式"><a href="#Detached-模式" class="headerlink" title="Detached 模式"></a>Detached 模式</h4><p>如果你在<code>docker container run</code> 命令的后面使用 <code>-d</code> 参数，那么容器就会进入 <code>detached</code>模式运行。成为一个后台进程，并不会输出容器中的输出内容，也不会传递信号。比如你可以尝试如下的命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run -d -p 80:80 nginx</span><br><span class="line">c10483e35e0144401750b02c37ff72f047a4048357aa49a76a2b83b487a4a618</span><br><span class="line">## 我们也可以通过 docker 的 attach 命令将容器从 detached 模式切换到 attached 模式</span><br><span class="line">$ sudo docker attach c1048</span><br></pre></td></tr></table></figure><p>在 <code>detached</code> 模式下，我们可以通过<code>docker container log</code> 来查看指定容器中的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container logs c104</span><br><span class="line">/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration</span><br><span class="line">/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/</span><br><span class="line">/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh</span><br></pre></td></tr></table></figure><p>使用 <code>-f</code> 参数可以动态的查看日志，类似于 <code>tail -f</code> Linux 命令。</p><h4 id="可交互模式"><a href="#可交互模式" class="headerlink" title="可交互模式"></a>可交互模式</h4><p>经常我们可能需要进入容器内部查看一些信息或者做某些操作，这时候我们就可以使用可交互模式来运行容器。如下示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run -it ubuntu sh</span><br><span class="line"># 省略部分输出内容</span><br><span class="line"># ls</span><br><span class="line">bin  boot  devetc  home  liblib32  lib64  libx32  media  mnt  opt  proc  root  runsbin  srv  systmp  usr  var</span><br><span class="line"></span><br><span class="line">加上 `-it` 参数就进入了交互模式，可以在最后面加上要在容器中执行的命令。如果执行的是`sh` 命令，就可以在运行的`sh` 中，执行连续的命令。</span><br></pre></td></tr></table></figure><p>对于一个已经在运行中的容器来说，我们可以使用<code>exec</code> 子命令来进入交互模式，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run -d nginx</span><br><span class="line">a170710178b2b89f29fa3b362bb65737ae5bbd8ed88a3542d31fb902c747d272</span><br><span class="line">$ sudo docker container exec -it a17 sh</span><br><span class="line"># ls</span><br><span class="line">bin   dev   docker-entrypoint.sh  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  docker-entrypoint.d  etc lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure><h3 id="更多的操作"><a href="#更多的操作" class="headerlink" title="更多的操作"></a>更多的操作</h3><p>更多的操作如下面表格所示:</p><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>docker container stop</td><td>停止容器</td></tr><tr><td>docker container restart</td><td>重启容器</td></tr><tr><td>docker container pause</td><td>暂停容器</td></tr><tr><td>docker container unpause</td><td>恢复暂停的容器</td></tr><tr><td>docker container attach</td><td>连接到后台运行的容器的终端</td></tr><tr><td>docker container logs</td><td>查看指定容器的日志，一般配合参数 <code>-t</code> 和 <code>-f</code> 使用，前者显示时间戳，后者实时输出</td></tr><tr><td>docker container top</td><td>查看容器的进程信息</td></tr><tr><td>docker container diff</td><td>查看容器中的文件修改</td></tr><tr><td>docker container rm</td><td>删除容器, 不能删除正在运行的容器，除非使用<code>-f</code>参数</td></tr></tbody></table><p>上面的一些命令可以批量操作，比如说<code>stop</code>、<code>rm</code> 等。批量操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container ps -qa)</span><br></pre></td></tr></table></figure><p>其中, <code>-q</code> 表示只显示容器的 ID， 而 <code>-a</code> 表示显示所有的容易，包括哪些已经退出的。我们可以使用下面的指令，快捷删除所有已经退出的容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker system prune -f</span><br><span class="line">Deleted Containers:</span><br><span class="line">8e45a9612cc11a678114565770a0e2d4583832f40ccbf0aa39290caa70ce34d4</span><br><span class="line">7b85a7987e1a18e58639a8c7735666ee414ff8d37bcf0477fd6f8fd343c2c414</span><br><span class="line"></span><br><span class="line">Total reclaimed space: 3.279kB</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker和容器</title>
      <link href="/2021/03/08/Docker%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/03/08/Docker%E5%92%8C%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<!-- 解决引用图片不显示问题 --><meta name="referrer" content="no-referrer"/><blockquote><p>海纳百川，有容乃大；壁立千仞，无欲则刚。    ——林则徐</p></blockquote><h3 id="什么是docker？"><a href="#什么是docker？" class="headerlink" title="什么是docker？"></a>什么是docker？</h3><p>什么是 Docker，它是一个开源的应用容器引擎。首先它是开源的，使用 Go 语言编写。接着，他是一个应用容器引擎。容器，是用来承装内容，而此处的内容指的是应用，即我们开发出来的软件系统。既然是软件，就会有其运行环境。既然是系统，就会有很多的模块、组建、依赖。<strong>而 Docker 就可以将软件系统(application)这一切打包、存储、发行、运行、管理、更新乃至销毁。</strong></p><p>什么是容器？我们来看看 Docker 官网上的一篇介绍 —— <a href="https://www.docker.com/resources/what-container">What is a Container?</a> 接下来的内容，是我对这篇文章的翻译。</p><span id="more"></span><h3 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h3><blockquote><p>A standardized unit of software</p></blockquote><p>什么是容器？软件最基本的单位。</p><blockquote><p>Package Software into Standardized Units for Development, Shipment and Deployment</p></blockquote><p>将软件包装成用于开发、运维以及部署的最基本的单位。</p><blockquote><p>A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings.</p></blockquote><p>一个容器是软件的最基本的单位，其封装了代码以及相关的全部依赖，所以可以在一台或多台的计算机环境中快速以及稳定的运行。一个 Docker 容器镜像是轻量级、单一的、可执行的软件包，其包含了软件在运行中所需的代码、运行时、系统工具、系统库以及相关的配置。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590554254859-96c34c24-c130-40d2-a1d6-e5008a0be7ee.png" alt="Containerized Applications"></p><blockquote><p>Container images become containers at runtime and in the case of Docker containers images become containers when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging.</p></blockquote><p>当 Docker 的容器镜像在 Docker 引擎中运行的时候会成为容器。而且无论是 Linux 还是基于 Windows 的应用，在各种基础架构中都能良好的运行。容器能够隔离软件的运行环境以确保他们的工作表现是一致的，即使是开发和生产环境是存在些许的差异。</p><h3 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h3><p>那么容器和虚拟机之间有什么区别呢？</p><blockquote><p>Containers and virtual machines have similar resource isolation and allocation benefits, but function differently because containers virtualize the operating system instead of hardware. Containers are more portable and efficient.</p></blockquote><p>容器和虚拟机都有着类似的资源隔离和分配机制，但是两者的功能不尽相同。因为容器是基于操作系统层面的虚拟化，而虚拟机是基于硬件的虚拟化。所以，相对于虚拟机，容器更加的轻量以及高效。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590558227231-5c9e0c3f-2595-429b-959d-f84d727ed419.png"></p><blockquote><p>Containers are an abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same machine and share the OS kernel with other containers, each running as isolated processes in user space. Containers take up less space than VMs (container images are typically tens of MBs in size), can handle more applications and require fewer VMs and Operating systems.</p></blockquote><p>容器是在应用层的抽象，它封装了代码以及相关的依赖。多个容器可以运行在数相同的机器上，并且与其他容器共享系统的内核。每个容器运行的进程都是在用户态中隔离的。容器相对于虚拟机消耗更少的空间(容器镜像通常只有十多兆的大小）。只需要更少的虚拟机和操作系统资源，就可以运行更多的应用。</p><blockquote><p>Virtual machines (VMs) are an abstraction of physical hardware turning one server into many servers. The hypervisor allows multiple VMs to run on a single machine. Each VM includes a full copy of an operating system, the application, necessary binaries and libraries - taking up tens of GBs. VMs can also be slow to boot.</p></blockquote><p>虚拟机是对物理硬件的抽象，可以将一台服务器转化为多台服务器。Hypervisor 允许多个虚拟机运行在单台机子上。每个虚拟机都包含了一个完整的操作系统，以及应用程序、必不可少的二进制文件和库 - 其花费的空间通常是十多 GB。虚拟机启动的更慢。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590558971581-58c8e33c-a56b-413e-8fc2-8245881b50ae.png"></p><p>Containers and VMs used together provide a great deal of flexibility in deploying and managing app.</p><p>容器和虚拟机的结合，可以让我们更加灵活的部署和管理应用。</p><h3 id="docker的架构"><a href="#docker的架构" class="headerlink" title="docker的架构"></a>docker的架构</h3><blockquote><p>Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface.</p></blockquote><p>Docker 使用的是 C&#x2F;S (客户端&#x2F;服务器) 架构。由 Docker 的客户端区请求 Docker 引擎，由其完成 Docker 容器从构建、运行到分发的生命周期。Docker 的客户端以及 Docker 引擎可以运行在同一个系统中，或者你可以使用客户端连接到远程的 Docker 引擎。Docker 的客户端和 Docker 引擎通过 REST API 来进行通信，或者通过 UNIX Sockets 或网络接口。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590582126138-48d5a861-2bbc-45d8-939d-82426ed14b13.png"></p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>安装 Docker 在 CentOS7 中，下面给出 Shell 的脚本，已经将镜像更换外阿里云:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">## Install use yum</span><br><span class="line">yum install -y yum-utils</span><br><span class="line">## 设置yum源</span><br><span class="line">### （中央仓库）</span><br><span class="line">yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">### （阿里仓库）</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">## 部署docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line">## Start Service</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">docker --version</span><br><span class="line">## 如果出现没有权限，可以将用户添加到 docker 的用户组中</span><br><span class="line">gpasswd -a vagrant docker</span><br><span class="line"></span><br><span class="line">## Modify docker registry image</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>其他的系统或发行版，请参考官方文档: <a href="https://docs.docker.com/engine/install/">Docker Install</a> 。官方脚本安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;curl -sSL https://get.docker.com/ | sh&quot;</span><br><span class="line">dockerd-rootless-setuptool.sh install</span><br><span class="line">## 将下面这两行追加到 ~/.bashrc 配置文件中</span><br><span class="line">export PATH=/usr/bin:$PATH</span><br><span class="line">export DOCKER_HOST=unix:///run/user/1000/docker.sock</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Docker 是 C&#x2F;S 架构的，包含 Docker Cli 以及 Docker Engine，我们可以通过 Docker Cli 来操作 Docker Engine。</p><p>我们可以使用 Docker 来打包应用，打包后的应用成为了 Docker 容器镜像。而 Docker 容器镜像在 Docker Engine 中运行的时候，我们就称之为容器或者说是容器的实例。</p><p>另外我们也对比了容器和虚拟机的区别，容器相对虚拟机更加的轻量级，而在实际的生产中，他们都不是孤立存在的，而是相互结合，共同作用于我们的应用的生产、部署过程中。</p><p><strong>容器的本质是进程</strong>，<strong>在进程的基础上对资源进行隔离、限制。</strong></p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
