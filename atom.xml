<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aimer&#39;s blog</title>
  
  <subtitle>醉后不知天在水，慢船清梦压星河</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-08T07:38:06.884Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Aimer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DockerCompose</title>
    <link href="http://example.com/2023/03/08/DockerCompose/"/>
    <id>http://example.com/2023/03/08/DockerCompose/</id>
    <published>2023-03-08T07:28:30.000Z</published>
    <updated>2023-03-08T07:38:06.884Z</updated>
    
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfilex详解</title>
    <link href="http://example.com/2023/03/08/Dockerfilex%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/03/08/Dockerfilex%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-03-08T07:28:19.000Z</published>
    <updated>2023-03-08T07:38:17.517Z</updated>
    
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile配置</title>
    <link href="http://example.com/2023/03/08/Dockerfile%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/03/08/Dockerfile%E9%85%8D%E7%BD%AE/</id>
    <published>2023-03-08T07:28:17.000Z</published>
    <updated>2023-03-08T07:39:02.607Z</updated>
    
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://example.com/2023/03/08/Docker%20Registry/"/>
    <id>http://example.com/2023/03/08/Docker%20Registry/</id>
    <published>2023-03-08T07:27:56.000Z</published>
    <updated>2023-03-08T07:37:59.309Z</updated>
    
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络管理</title>
    <link href="http://example.com/2023/03/08/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/03/08/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-08T07:27:49.000Z</published>
    <updated>2023-03-08T07:51:36.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在这一篇文档中，你讲看到 Docker 中如何进行网络的管理，包括网络的类型以及它们的应用。</p></blockquote><h3 id="默认的网络类型"><a href="#默认的网络类型" class="headerlink" title="默认的网络类型"></a>默认的网络类型</h3><p>当我们安装好 Docker 之后，就已经创建了三个默认的网络，可以使用如下命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">dff28c734f9f   bridge    bridge    local</span><br><span class="line">1e7467b6d95b   host      host      local</span><br><span class="line">2ea4d9c5d1fb   none      null      local</span><br></pre></td></tr></table></figure><span id="more"></span><p>下面我们分别来介绍和演示这三种网络类型。我们可以通过如下命令来查看网络的详细信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network inspect bridge | grep Name ## 过滤掉除名字外其他的内容</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br></pre></td></tr></table></figure><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>Bridge 是桥接网络, 默认情况下，我们创建的容器如果没有指定网络（使用 <code>--network</code> 参数指定）使用的就是桥接网络。<strong>桥接网络的特点是，容器之间是可以相互通信的，但是容器和主机是不能联通的，需要通过 iptables 来实现端口映射。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name test_1 ubuntu:16.04 /bin/sh## 创建第一个容器</span><br><span class="line">$ docker run -itd --name test_2 --network bridge ubuntu:16.04 /bin/sh  ## 创建第二个容器</span><br></pre></td></tr></table></figure><p>然后我们分别查看两个容器的 IP 以及子网:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect test_1 | grep -E &quot;IPAddress|Gateway|IPPrefixLen&quot; | head -n4</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">$ docker inspect test_2 | grep -E &quot;IPAddress|Gateway|IPPrefixLen&quot; | head -n4</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br></pre></td></tr></table></figure><p>我们看到这两个容器都在同一个网段内，你可以使用 <code>docker attach</code> 来验证网络是否互联:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 默认情况下，这个 Ubuntu:16.04 没有安装 ping，安装如下</span><br><span class="line">apt update</span><br><span class="line"></span><br><span class="line">apt install iputils-ping</span><br><span class="line">## 安装完成之后</span><br><span class="line">ping 172.12.0.3 ## test_2 容器也是一样的过程</span><br></pre></td></tr></table></figure><p>我们前面也说到了，如果要在主机上访问容器中的服务，是通过 iptables 实现端口映射的。我们来做一个实验，创建一个 Apache 的容器，Dockerfile 如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER JinZhiSu/happy@hacking.icu</span><br><span class="line">ENV DEBIAN_FRONTEND noninteractive</span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get -yqq install dialog &amp;&amp; apt-get install -yqq apache2</span><br><span class="line">CMD [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure><p>然后构建镜像，并创建容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t apache:1.0 .</span><br><span class="line">docker run -d -p 10001:80 --name web apache:1.0</span><br></pre></td></tr></table></figure><p>然后查看 iptable 的规则，你可以看到 <code>DNAT</code> 的规则发生了变化:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -t nat -nvL</span><br><span class="line">## ...省略部分内容...</span><br><span class="line">5   320 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:10001 to:172.17.0.2:80</span><br><span class="line">## ...省略部分内容...</span><br></pre></td></tr></table></figure><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>默认的 bridge 网络，每次重启容器，容器的 IP 都会发生变化。对于默认的 bridge 网络，不能在启动容器的时候指定 IP。为了达到这个目的，我们可以使用自定义网络。在旧版的 Docker 中，通常通过 <code>--link</code> 参数来实现容器互联，但是现在已经不推荐这么做了，所以就不讲了。</p><p>首先要创建一个自定义的网路，设定驱动为 <code>bridge</code> 桥接模式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker network create my-net</span><br><span class="line">9095a08fdf7d071da19861467665d4d323d5696baa5b9cf416c0ca591499e3f4</span><br><span class="line">$ sudo docker network ls</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">9095a08fdf7d   my-net    bridge    local## 我们自己创建的网络</span><br></pre></td></tr></table></figure><p>然后创建两个容器，全部指定网络为刚才我们创建的这个自定义网络:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -itd --name test3 --network my-net ubuntu:14.04 /bin/sh</span><br><span class="line">$ sudo docker run -itd --name test4 --network my-net ubuntu:14.04 /bin/sh</span><br><span class="line">$ sudo docker attach test3</span><br><span class="line"># ping test4## 可以使用容器名字替换 IP</span><br><span class="line">PING test4 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from test4.my-net (172.18.0.3): icmp_seq=1 ttl=64 time=0.106 ms## 证明容器之间可以相互联通</span><br></pre></td></tr></table></figure><h3 id="Host-网络"><a href="#Host-网络" class="headerlink" title="Host 网络"></a>Host 网络</h3><p>Host 网络指的是容器和主机可以互联。举个例子来说, 我们可以通过容器采用 Host 网络实现，将容器中的服务端口直接注册到本地，就如同本地创建了这个服务一般:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --name web -d --network host nginx</span><br><span class="line">3bab7527ac3855dcd13bfb4d9e2f21dce1ba6f48883c54d5a99f4d10e6dfb42c</span><br><span class="line"></span><br><span class="line">$ curl localhost</span><br><span class="line">......输出省略</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">......输出省略</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="None-网络"><a href="#None-网络" class="headerlink" title="None 网络"></a>None 网络</h3><p>none 网络指的是在容器中不提供其他网络接口。none 网络的容器创建之后还可以自己 connect 一个网络，比如使用 <code>docker network connect bridge 容器名</code> 可以将这个容器加入到 bridge 网络中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在这一篇文档中，你讲看到 Docker 中如何进行网络的管理，包括网络的类型以及它们的应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;默认的网络类型&quot;&gt;&lt;a href=&quot;#默认的网络类型&quot; class=&quot;headerlink&quot; title=&quot;默认的网络类型&quot;&gt;&lt;/a&gt;默认的网络类型&lt;/h3&gt;&lt;p&gt;当我们安装好 Docker 之后，就已经创建了三个默认的网络，可以使用如下命令查看：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo docker network ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NETWORK ID     NAME      DRIVER    SCOPE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dff28c734f9f   bridge    bridge    local&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1e7467b6d95b   host      host      local&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2ea4d9c5d1fb   none      null      local&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>存储管理</title>
    <link href="http://example.com/2023/03/08/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/03/08/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-08T07:27:42.000Z</published>
    <updated>2023-03-08T07:50:52.254Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文档描述了在 Docker 中管理数据的几种方式。包括如何使用 volumes, 使用 bind mounts, 使用 tmpfs, 数据卷容器，数据卷的备份以及恢复等。</p></blockquote><h3 id="数据保存在容器中"><a href="#数据保存在容器中" class="headerlink" title="数据保存在容器中"></a>数据保存在容器中</h3><p>直到目前为止，我们的数据都直接存储在 Docker 的容器当中，容器本质上就是一个进程，存储在容器中也就是存储在内存中，这会存在一些问题:</p><ul><li>当容器不再运行的时候，我们无法使用数据。</li><li>当容器被删除的时候，数据也会跟着消失。</li><li>数据保存在容器的可写层中，我们无法轻松的把数据迁移到其他地方。</li></ul><p>所以，我们需要考虑数据如何持久化的问题。</p><span id="more"></span><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Docker 提供了卷(Volumes)、挂载(Bind Mounts)、临时文件系统(Tmpfs) 这几种方式，大多数情况下，我们只会使用卷。</p><ul><li>Volumes: 卷存储在 Docker 管理的主机文件系统中，具体的目录是 <code>/var/lib/docker/volumes</code> ，完全由 Docker 管理。</li><li>Bind Mounts: 绑定挂载，可以将主机上的文件或者目录挂载到容器中。</li><li>Tmpfs: 仅存储在主机系统的内存中，而不会写入主机的文件系统。</li></ul><h4 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h4><p>我们可以使用如下命令来创建一个卷:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create  ## 会随机生成一个 Volume 的名字</span><br><span class="line">c4dbf70166cc480b2f7e6b77da8ca0747395eba8dd1262456c9003842713ab5f    ## Volume 的名字</span><br></pre></td></tr></table></figure><p>查看当前已经创建的 Volume：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               c4dbf70166cc480b2f7e6b77da8ca0747395eba8dd1262456c9003842713ab5f</span><br></pre></td></tr></table></figure><p>这种随机命名的卷，也称之为 <strong>匿名卷</strong> 。我们也可以在创建 Volume 的时候，手动指定名称:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create mysql_data</span><br><span class="line">mysql_data</span><br><span class="line">$ docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               c4dbf70166cc480b2f7e6b77da8ca0747395eba8dd1262456c9003842713ab5f</span><br><span class="line">local               mysql_data</span><br></pre></td></tr></table></figure><p>创建了一个 Volume 之后，我们就可以在启动一个容器的时候，指定这个数据卷。当我们运行 <code>docker run</code> 命令的时候，就可以使用 <code>-v</code> 或者 <code>--volume</code> 参数来指定卷，被指定的卷可以和容器中的目录或文件做映射(即你访问容器中的该目录就等于是访问主机中的卷, 实际上，该卷是位于主机中的):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v [host-dir:]container-dir[:options]</span><br></pre></td></tr></table></figure><p>命令的格式就如上所示，当中的参数我们分别来讲:</p><ul><li><code>host-dir</code> ：指定主机当中的卷，这是可以省略的，如果省略的话，就会创建一个匿名卷，如果指定的是主机上的目录的话，就需要使用绝对路径。</li><li><code>container-dir</code> ：这个指的是挂载到容器上的目录或文件。</li><li><code>options</code> ：这个选项的取值范围为 <code>[rw|ro,][z|Z]</code> ，其中 <code>rw</code> 表示可读可写， <code>ro</code> 表示只读。这两种模式可以搭配 <code>[z|Z]</code> ，使用 <code>,</code>  分隔，其中 <code>z</code> 表示该卷可以被多个容器使用，而 <code>Z</code> 表示这个卷只能被当前的容器使用。</li></ul><p>在实际的使用过程中，我们更推荐使用 <code>--mount</code> 选项来指定卷, 格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --mount type=volume,src=named_volume,target=container-path,readonly=true</span><br></pre></td></tr></table></figure><p>命令的格式就如上所示，当中的参数我们分别来讲:</p><ul><li><code>type</code> ，挂载的类型，取值范围为 <code>bind</code> 、 <code>volume</code> 、 <code>tmpfs</code> 。</li><li><code>source</code> ，指的是主机管理的命名卷，也可以写成 <code>src</code> 。</li><li><code>dst</code>  ，也可以写成 <code>destination</code> 、 <code>target</code> 。卷在容器中映射的文件或者目录。</li><li><code>readonly</code> ， 取值范围为 <code>true</code> 或者 <code>false</code> ，卷是否只读。</li></ul><p>下面我们创建一个 Volume 并创建容器使用它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create test_volume## 创建一个卷</span><br><span class="line">test_volume</span><br><span class="line">## 创建容器并指定卷</span><br><span class="line">$ docker container run -it --name test_contianer --mount type=volume,src=test_volume,dst=/volume --rm ubuntu /bin/sh</span><br><span class="line"># cd /voume     ## 可以进入卷，当我们在这个容器中往当中写入内容的时候，会同步到主机管理的卷中，不会随着容器删除而消失</span><br></pre></td></tr></table></figure><h4 id="Bind-Mounts"><a href="#Bind-Mounts" class="headerlink" title="Bind Mounts"></a>Bind Mounts</h4><p>Bind Mounts 这种形式就是将主机上的目录直接绑定到容器中去，实现在容器中对主机目录的读写。我们来实验一下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run -it --mount type=bind,src=/home/vagrant/host-dir,dst=/docker-dir --name test2 --rm ubuntu /bin/sh</span><br><span class="line"># cd /docker-dir</span><br><span class="line"># touch test1## 在容器中创建文件</span><br><span class="line"># exit</span><br><span class="line">$ ls## 主机中也已经存在该文件了</span><br><span class="line">test1</span><br></pre></td></tr></table></figure><h4 id="Tmpfs"><a href="#Tmpfs" class="headerlink" title="Tmpfs"></a>Tmpfs</h4><p>最后，我们演示一下使用 Tmpfs 方式，比上面两种更简单一些。当容器停止的时候，响应的数据就会被移除:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --munt type=tmpfs,dst=/test --name test --rm ubuntu /bin/sh</span><br></pre></td></tr></table></figure><h3 id="使用数据卷容器共享数据"><a href="#使用数据卷容器共享数据" class="headerlink" title="使用数据卷容器共享数据"></a>使用数据卷容器共享数据</h3><p>如果容器之间需要共享一些持续更新的数据，最简单的方式就是使用用户数据卷容器。其他的容器可以挂载这个容器实现数据共享，这个挂载的数据卷的容器就叫做数据卷容器。你可以理解成是把数据卷使用容器的方式启动。</p><p>我们可以在执行 <code>docker run</code> 的时候，使用 <code>--volumes-from</code> 参数来指定数据卷容器。下面的示例中，我们创建了一个数据卷容器以及两个普通的容器，这两个普通的容器都指向了数据卷容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker volume create vdata## 创建数据卷</span><br><span class="line">docker container run -it -v vdata:/vdata --name data_1 ubuntu /bin/bash  ## 创建数据卷容器</span><br><span class="line">docker container run -it --volumes-from data_1 --name data_2 ubuntu /bin/bash   ## 将 data_2 指向数据卷容器 1</span><br><span class="line">docker container run -it --volumes-from data_1 --name data_3 ubuntu /bin/bash   ## 将 data_3 指向数据卷容器 2</span><br></pre></td></tr></table></figure><p>这样我们就实现了两个容器共享一个数据卷容器。</p><h4 id="备份数据卷容器中的数据"><a href="#备份数据卷容器中的数据" class="headerlink" title="备份数据卷容器中的数据"></a>备份数据卷容器中的数据</h4><p>数据存储于数据卷中，如果我们想要备份它，可以采用创建备份容器的方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --volumes-from data_1 -v /home/vagrant/backup:/backup ubuntu tar cvf /backup/backup.tar /vdata/</span><br><span class="line">/vdata/</span><br><span class="line">/vdata/test.t</span><br><span class="line">tar: Removing leading `/` from member names</span><br><span class="line">$ ls /home/vagrant/backup/</span><br><span class="line">backup.tar## 备份的文件</span><br></pre></td></tr></table></figure><p>那么如何恢复文件呢？应该也是一样的道理吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --volumes-from data_1 -v /home/vagrant/backup:/backup ubuntu tar xvf /backup/backup.tar -C /</span><br><span class="line">vdata/</span><br><span class="line">vdata/test.t</span><br></pre></td></tr></table></figure><p>启动一个新的恢复容器，然后将数据解压到 <code>vdata</code> 的上一级目录中去。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文档描述了在 Docker 中管理数据的几种方式。包括如何使用 volumes, 使用 bind mounts, 使用 tmpfs, 数据卷容器，数据卷的备份以及恢复等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据保存在容器中&quot;&gt;&lt;a href=&quot;#数据保存在容器中&quot; class=&quot;headerlink&quot; title=&quot;数据保存在容器中&quot;&gt;&lt;/a&gt;数据保存在容器中&lt;/h3&gt;&lt;p&gt;直到目前为止，我们的数据都直接存储在 Docker 的容器当中，容器本质上就是一个进程，存储在容器中也就是存储在内存中，这会存在一些问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当容器不再运行的时候，我们无法使用数据。&lt;/li&gt;
&lt;li&gt;当容器被删除的时候，数据也会跟着消失。&lt;/li&gt;
&lt;li&gt;数据保存在容器的可写层中，我们无法轻松的把数据迁移到其他地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，我们需要考虑数据如何持久化的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>镜像管理</title>
    <link href="http://example.com/2023/03/08/%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/03/08/%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-08T07:27:31.000Z</published>
    <updated>2023-03-08T07:47:47.624Z</updated>
    
    <content type="html"><![CDATA[<p>什么是镜像呢？镜像就是一个模版，用来创建容器的模板。当我们执行“docker run”的时候，会首先查找本地是否存在对应的镜像，如果不存在则会在 Docker Registry 上查找下载。Docker 的镜像是增量的修改，每次创建新的镜像都会在老的镜像上面构建一个增量的层(Layer)，有利于层的复用，减少镜像的体积，利于网络传输。</p><p>我们先来说几个镜像相关的概念，比如说 Repository 是镜像存储的位置，名为仓库。而 Registry 是镜像仓库的注册服务器，每个仓库中都包含了很多的镜像。每个镜像还会又一个 Tag（标签), 这个 Tag 我们一般会标记为镜像的版本，这点就 Git 中的版本的概念是一致的。比如说 <code>Ubuntu:14.04</code> ，其中 <code>Ubuntu</code> 就是镜像的名字，而 <code>14.04</code> 是它的 Tag，也是它的版本。</p><span id="more"></span><h3 id="镜像的基本操作"><a href="#镜像的基本操作" class="headerlink" title="镜像的基本操作"></a>镜像的基本操作</h3><p>然后我们可以使用 <code>docker image ls</code> 命令来查看本地的镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   14 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>指定镜像的名称也是可以的， 指定版本可以使用 <code>镜像名字:版本</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls hello-world</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    bf756fb1ae65   14 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>如果要查看一个镜像的详细信息，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect hello-world | grep Id   ## 输出太多的内容，过滤一下</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:bf756fb1ae65adf866bd8c456593cd24beb6a0a061dedf42b26a993176745f6b&quot;,</span><br></pre></td></tr></table></figure><p>联网搜索镜像使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker search ubuntu | head -n2  ## 输出太多的内容，过滤一下</span><br><span class="line">NAME                                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">ubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   11992     [OK]</span><br></pre></td></tr></table></figure><p>拉取镜像使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker image pull ubuntu:14.04</span><br><span class="line">14.04: Pulling from library/ubuntu</span><br><span class="line">2e6e20c8e2e6: Pull complete</span><br><span class="line">## ...省略部分输出内容...</span><br></pre></td></tr></table></figure><p>对于拉取下来的镜像，默认的存储路径如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ls /var/lib/docker/overlay2  ## 省略输出内容</span><br></pre></td></tr></table></figure><h3 id="镜像的创建"><a href="#镜像的创建" class="headerlink" title="镜像的创建"></a>镜像的创建</h3><p>创建新的镜像有两种方式，一种方式是修改已经创建的容器，在这个基础上创建镜像，另一种方式是使用 Dockerfile 文件来创建镜像。在生产环境下，我们推荐使用第二种方式来创建镜像。</p><h4 id="修改已经存在的容器创建镜像"><a href="#修改已经存在的容器创建镜像" class="headerlink" title="修改已经存在的容器创建镜像"></a>修改已经存在的容器创建镜像</h4><p>如果我们要创建一个新的镜像，可以基于一个已经存在的镜像。用它来创建一个容器，然后在容器中进行修改，之后提交到一个新的镜像中去:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -it --name test busybox /bin/sh</span><br><span class="line">## ...省略部分输出内容...</span><br><span class="line">/ # touch test1 test2## 在容器中创建两个新的文件</span><br><span class="line">## 使用 CTRL+P 以及 CTRL+Q 退出容器</span><br></pre></td></tr></table></figure><p>在退出容器之后，我们使用 <code>docker container commit</code> 命令来创建一个新的镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container commit test new_test## 由当前运行着的 test 容器创建出一个新的镜像，名为 new_test</span><br><span class="line">sha256:6c88835118a947a1d2af0313157bb0a55204299f9ff4096297fefabe18a987e2</span><br></pre></td></tr></table></figure><p>但是这种方法并不建议在生产环境中使用，因为这样创建出来的镜像非常难以维护。我们推荐使用 Dockerfile 的方式来创建一个新的镜像。</p><h4 id="使用-Dockerfile-创建镜像"><a href="#使用-Dockerfile-创建镜像" class="headerlink" title="使用 Dockerfile 创建镜像"></a>使用 Dockerfile 创建镜像</h4><p>Dockerfile 文件是一个用来描述镜像的创建过程的文件，换句话说我们通过 Dockerfile 这个文件告诉 Docker，我们这个镜像的一些基本信息，如何创建这个镜像，创建这个镜像之后要做什么事情。怎么告诉呢？通过预定义的一些指令,指令的格式如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTRUCTION arguments   ## 它是有指令和参数构成的，就和 Linux 下的命令是一样的逻辑</span><br></pre></td></tr></table></figure><p>那么一个基本的 Dockerfile 都包含那些内容呢？其实这个问题的答案也就是我们之前提的几个问题的答案，如何创建这个镜像？创建之后要干什么？</p><ol><li>基础镜像：我们大概不会从零创建一个镜像，我们需要一个以某个镜像为基础，在这个基础上增加我们自己的内容，使用 <code>FROM</code> 指令来指定。</li><li>维护者信息: 这个镜像是谁维护的，除了问题找谁？通过 <code>MAINTAINER</code> 指令可以指定维护者的名字和邮箱。</li><li>镜像操作命令：我们要在基础镜像上进行那些修改？是创建文件还是安装服务器环境或者进行特殊的配置？常用的命令是 <code>RUN</code> ，运行 Shell 的命令或脚本。</li><li>容器的启动命令：当容器启动的时候需要执行那些命令或脚本？使用指令 <code>CMD</code> 或者 <code>ENTRYPOINT</code> 。</li></ol><p>说了那么多，我们来创建一个 Dockerfile：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line">MAINTAINER JinZhiSu/happy@hacking.icu</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install apache2</span><br><span class="line">CMD [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]## CMD 只能出现一次，如果出现多次，只会执行最后一条命令</span><br></pre></td></tr></table></figure><p>通过短短 4 行，我们就创建了一个新的 Dockerfile, 也就创建了一个新的镜像。但是，我们还需要让这个 Dockerfile 通过 docker 成为真正的镜像文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build .## . 表示当前目录，会自动查找当前目录下的 Dockerfile, 当然我们也可以使用 -t 参数来指定具体的 Dockerfile 文件</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : FROM ubuntu:14.04</span><br><span class="line"># ...省略更多输出...</span><br></pre></td></tr></table></figure><p>然后我们可以通过 <code>docker image ls</code> 命令来查看刚刚创建的 Docker 镜像:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls                                                                    [15:42:04]</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">&lt;none&gt;                          &lt;none&gt;              2d59468593eb        About a minute ago   197MB</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>删除一个镜像可以使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm 956## 不能删除已经被容器使用的镜像</span><br><span class="line">956</span><br><span class="line">$ docker image rm 2d5</span><br><span class="line">Deleted: sha256:2d59468593ebb585aa82cd02989cada50c3145979858801555115c358a1af8d5</span><br></pre></td></tr></table></figure><p>如果要批量删除没有使用的镜像，可以如下示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><h3 id="镜像的导入和导出"><a href="#镜像的导入和导出" class="headerlink" title="镜像的导入和导出"></a>镜像的导入和导出</h3><p>当我们在内网或者其他特殊的网络环境下，无法连接到 Registry 的时候，就可以通过将已经存在的镜像导出到存储设备中，然后在对应的环境中部署。</p><p>镜像的导出如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED      SIZE</span><br><span class="line">ubuntu       latest    c29284518f49   7 days ago   72.8MB</span><br><span class="line">$ docker image save ubuntu -o ubuntu.image</span><br><span class="line">$ ls</span><br><span class="line">ubuntu.image</span><br></pre></td></tr></table></figure><p>导入镜像如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image load -i ./ubuntu.image</span><br><span class="line">a70daca533d0: Loading layer [==================================================&gt;]  75.16MB/75.16MB</span><br><span class="line">Loaded image: ubuntu:latest</span><br></pre></td></tr></table></figure><h3 id="运行-MySQL-容器"><a href="#运行-MySQL-容器" class="headerlink" title="运行 MySQL 容器"></a>运行 MySQL 容器</h3><p>关于 MySQL 的镜像，我们可以参考<a href="https://hub.docker.com/_/mysql">官方文档</a>。如果环境变量比较多，我们可以创建一个文件用来保存，而不是通过命令的方式指定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_ROOT_PASSWORD=root</span><br><span class="line">MYSQL_DATABASE=test</span><br><span class="line">MYSQL_USER=shiyanlou</span><br><span class="line">MYSQL_PASSWORD=Xbcd20198$</span><br></pre></td></tr></table></figure><p>然后我们来运行 MySQL 的容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -d --env-file ./env_file -p 3306:3306 mysql:5.5</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是镜像呢？镜像就是一个模版，用来创建容器的模板。当我们执行“docker run”的时候，会首先查找本地是否存在对应的镜像，如果不存在则会在 Docker Registry 上查找下载。Docker 的镜像是增量的修改，每次创建新的镜像都会在老的镜像上面构建一个增量的层(Layer)，有利于层的复用，减少镜像的体积，利于网络传输。&lt;/p&gt;
&lt;p&gt;我们先来说几个镜像相关的概念，比如说 Repository 是镜像存储的位置，名为仓库。而 Registry 是镜像仓库的注册服务器，每个仓库中都包含了很多的镜像。每个镜像还会又一个 Tag（标签), 这个 Tag 我们一般会标记为镜像的版本，这点就 Git 中的版本的概念是一致的。比如说 &lt;code&gt;Ubuntu:14.04&lt;/code&gt; ，其中 &lt;code&gt;Ubuntu&lt;/code&gt; 就是镜像的名字，而 &lt;code&gt;14.04&lt;/code&gt; 是它的 Tag，也是它的版本。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>容器管理</title>
    <link href="http://example.com/2021/03/08/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2021/03/08/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</id>
    <published>2021-03-08T07:57:12.000Z</published>
    <updated>2023-03-08T07:50:17.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这一篇文档描述了容器管理的一些命令，比如启动容器、退出容器、关闭容器、删除容器等。容器的管理使用 <code>docker contaner</code> 命令。</p></blockquote><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>我们从 Hello World 开始，如何创建一个容器呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run hello-world</span><br></pre></td></tr></table></figure><p><code>docker run</code> 是一条复合命令，严格来说并不是创建容器的命令。创建容器使用 <code>docker create</code> 命令，在说它之前先来说说 <code>docker run</code> 都做了什么事情？</p><ol><li>检查本地是否存在指定的镜像</li><li>如果不存在指定的镜像，则连接 Dcoker Registry 下载</li><li>下载之后创建容器</li><li>创建容器之后运行容器, 启动容器可以用 <code>docker container start</code> 命令</li></ol><span id="more"></span><p><code>docker run</code> 有一些常用的参数，如下:</p><ul><li><code>-i</code> 或者 <code>--interactive</code> : 交互模式</li><li><code>-t</code> 或者 <code>--tty</code> ：分配一个 <code>pseduo-TTY</code> ，伪终端</li><li><code>--rm</code> ：在容器退出后自动移除</li><li><code>-p</code> ：将容器的端口映射到主机</li><li><code>-v</code> 或 <code>--volume</code> ：指定数据卷</li></ul><p>我们也可以在后面加上容器运行后要执行的 Shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run busybox echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>如果我们希望容器保持运行，可以指定 <code>-it</code> 参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -i -t ubuntu /bin/bash</span><br><span class="line">root@14b5c7524f2f: /#</span><br></pre></td></tr></table></figure><p>默认情况下，主机名 <code>14b5c7524f2f</code> 是容器的 ID。那么我们如何退出容器呢？可以在终端输入 <code>exit</code> ，然后使用如下命令观察容器的状态:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a # 你可以看到状态为 Exited</span><br></pre></td></tr></table></figure><p>我们也可以指定 <code>-d</code> 参数，让容器在后台运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container run -itd ubuntu /bin/bash</span><br><span class="line">## 观察容器状态，应该为 Up</span><br><span class="line">docker container ls## 如果不加上 -a, 只显示运行状态的容器</span><br></pre></td></tr></table></figure><p>然后，我们再来看看 <code>docker create</code> 命令，相对于 <code>docker run</code> 只会创建容器，但是不会运行。执行后返回容器的 ID:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container create --name shiyanlou \          ## 指定容器名称</span><br><span class="line">--hostname shiyanlou \          ## 指定 Hostname</span><br><span class="line">  --mac-address 00:01:02:03:04:05 \          ## 指定 mac 地址</span><br><span class="line">  --ulimit nproc=1024:2048 -it ubuntu /bin/bash## 指定 ulimit</span><br><span class="line">## 观察容器状态</span><br><span class="line">docker container ls  ## 应该是 Created</span><br></pre></td></tr></table></figure><p>查看 docker 容器的详细信息可以使用如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect [容器名称|容器ID]</span><br></pre></td></tr></table></figure><h3 id="容器的的运行模式"><a href="#容器的的运行模式" class="headerlink" title="容器的的运行模式"></a>容器的的运行模式</h3><p>容器有三种运行模式，分别是 <code>attached</code> 模式、<code>detached</code> 模式以及可交互模式。下文分别予以介绍。</p><h4 id="Attached-模式"><a href="#Attached-模式" class="headerlink" title="Attached 模式"></a>Attached 模式</h4><p>当你使用<code>docker container run</code> 命令来运行一个容器之后，容器就处于 <code>attached</code> 模式，容器中的输出会输出到当前的输出中，同样当前环境中信号的输入也会传递到容器中去。比如你使用<code>CTRL+C</code> ，信号也会传递给容器，从而停止容器进程的运行。</p><blockquote><p>注意: Windows 下并不支持完整的 Attached 模式，并不支持信号向容器的传递。所以即是你使用<code>CTRL+C</code>，也不会终止容器进程的运行。</p></blockquote><h4 id="Detached-模式"><a href="#Detached-模式" class="headerlink" title="Detached 模式"></a>Detached 模式</h4><p>如果你在<code>docker container run</code> 命令的后面使用 <code>-d</code> 参数，那么容器就会进入 <code>detached</code>模式运行。成为一个后台进程，并不会输出容器中的输出内容，也不会传递信号。比如你可以尝试如下的命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run -d -p 80:80 nginx</span><br><span class="line">c10483e35e0144401750b02c37ff72f047a4048357aa49a76a2b83b487a4a618</span><br><span class="line">## 我们也可以通过 docker 的 attach 命令将容器从 detached 模式切换到 attached 模式</span><br><span class="line">$ sudo docker attach c1048</span><br></pre></td></tr></table></figure><p>在 <code>detached</code> 模式下，我们可以通过<code>docker container log</code> 来查看指定容器中的输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container logs c104</span><br><span class="line">/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration</span><br><span class="line">/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/</span><br><span class="line">/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh</span><br></pre></td></tr></table></figure><p>使用 <code>-f</code> 参数可以动态的查看日志，类似于 <code>tail -f</code> Linux 命令。</p><h4 id="可交互模式"><a href="#可交互模式" class="headerlink" title="可交互模式"></a>可交互模式</h4><p>经常我们可能需要进入容器内部查看一些信息或者做某些操作，这时候我们就可以使用可交互模式来运行容器。如下示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run -it ubuntu sh</span><br><span class="line"># 省略部分输出内容</span><br><span class="line"># ls</span><br><span class="line">bin  boot  devetc  home  liblib32  lib64  libx32  media  mnt  opt  proc  root  runsbin  srv  systmp  usr  var</span><br><span class="line"></span><br><span class="line">加上 `-it` 参数就进入了交互模式，可以在最后面加上要在容器中执行的命令。如果执行的是`sh` 命令，就可以在运行的`sh` 中，执行连续的命令。</span><br></pre></td></tr></table></figure><p>对于一个已经在运行中的容器来说，我们可以使用<code>exec</code> 子命令来进入交互模式，如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker container run -d nginx</span><br><span class="line">a170710178b2b89f29fa3b362bb65737ae5bbd8ed88a3542d31fb902c747d272</span><br><span class="line">$ sudo docker container exec -it a17 sh</span><br><span class="line"># ls</span><br><span class="line">bin   dev   docker-entrypoint.sh  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  docker-entrypoint.d  etc lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure><h3 id="更多的操作"><a href="#更多的操作" class="headerlink" title="更多的操作"></a>更多的操作</h3><p>更多的操作如下面表格所示:</p><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>docker container stop</td><td>停止容器</td></tr><tr><td>docker container restart</td><td>重启容器</td></tr><tr><td>docker container pause</td><td>暂停容器</td></tr><tr><td>docker container unpause</td><td>恢复暂停的容器</td></tr><tr><td>docker container attach</td><td>连接到后台运行的容器的终端</td></tr><tr><td>docker container logs</td><td>查看指定容器的日志，一般配合参数 <code>-t</code> 和 <code>-f</code> 使用，前者显示时间戳，后者实时输出</td></tr><tr><td>docker container top</td><td>查看容器的进程信息</td></tr><tr><td>docker container diff</td><td>查看容器中的文件修改</td></tr><tr><td>docker container rm</td><td>删除容器, 不能删除正在运行的容器，除非使用<code>-f</code>参数</td></tr></tbody></table><p>上面的一些命令可以批量操作，比如说<code>stop</code>、<code>rm</code> 等。批量操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container ps -qa)</span><br></pre></td></tr></table></figure><p>其中, <code>-q</code> 表示只显示容器的 ID， 而 <code>-a</code> 表示显示所有的容易，包括哪些已经退出的。我们可以使用下面的指令，快捷删除所有已经退出的容器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker system prune -f</span><br><span class="line">Deleted Containers:</span><br><span class="line">8e45a9612cc11a678114565770a0e2d4583832f40ccbf0aa39290caa70ce34d4</span><br><span class="line">7b85a7987e1a18e58639a8c7735666ee414ff8d37bcf0477fd6f8fd343c2c414</span><br><span class="line"></span><br><span class="line">Total reclaimed space: 3.279kB</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这一篇文档描述了容器管理的一些命令，比如启动容器、退出容器、关闭容器、删除容器等。容器的管理使用 &lt;code&gt;docker contaner&lt;/code&gt; 命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h3&gt;&lt;p&gt;我们从 Hello World 开始，如何创建一个容器呢？&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker container run hello-world&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;docker run&lt;/code&gt; 是一条复合命令，严格来说并不是创建容器的命令。创建容器使用 &lt;code&gt;docker create&lt;/code&gt; 命令，在说它之前先来说说 &lt;code&gt;docker run&lt;/code&gt; 都做了什么事情？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查本地是否存在指定的镜像&lt;/li&gt;
&lt;li&gt;如果不存在指定的镜像，则连接 Dcoker Registry 下载&lt;/li&gt;
&lt;li&gt;下载之后创建容器&lt;/li&gt;
&lt;li&gt;创建容器之后运行容器, 启动容器可以用 &lt;code&gt;docker container start&lt;/code&gt; 命令&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker和容器</title>
    <link href="http://example.com/2021/03/08/Docker%E5%92%8C%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2021/03/08/Docker%E5%92%8C%E5%AE%B9%E5%99%A8/</id>
    <published>2021-03-08T07:27:08.000Z</published>
    <updated>2023-03-08T07:34:47.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>海纳百川，有容乃大；壁立千仞，无欲则刚。    ——林则徐</p></blockquote><h3 id="什么是docker？"><a href="#什么是docker？" class="headerlink" title="什么是docker？"></a>什么是docker？</h3><p>什么是 Docker，它是一个开源的应用容器引擎。首先它是开源的，使用 Go 语言编写。接着，他是一个应用容器引擎。容器，是用来承装内容，而此处的内容指的是应用，即我们开发出来的软件系统。既然是软件，就会有其运行环境。既然是系统，就会有很多的模块、组建、依赖。<strong>而 Docker 就可以将软件系统(application)这一切打包、存储、发行、运行、管理、更新乃至销毁。</strong></p><p>什么是容器？我们来看看 Docker 官网上的一篇介绍 —— <a href="https://www.docker.com/resources/what-container">What is a Container?</a> 接下来的内容，是我对这篇文章的翻译。</p><span id="more"></span><h3 id="什么是容器？"><a href="#什么是容器？" class="headerlink" title="什么是容器？"></a>什么是容器？</h3><blockquote><p>A standardized unit of software</p></blockquote><p>什么是容器？软件最基本的单位。</p><blockquote><p>Package Software into Standardized Units for Development, Shipment and Deployment</p></blockquote><p>将软件包装成用于开发、运维以及部署的最基本的单位。</p><blockquote><p>A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings.</p></blockquote><p>一个容器是软件的最基本的单位，其封装了代码以及相关的全部依赖，所以可以在一台或多台的计算机环境中快速以及稳定的运行。一个 Docker 容器镜像是轻量级、单一的、可执行的软件包，其包含了软件在运行中所需的代码、运行时、系统工具、系统库以及相关的配置。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590554254859-96c34c24-c130-40d2-a1d6-e5008a0be7ee.png" alt="Containerized Applications"></p><blockquote><p>Container images become containers at runtime and in the case of Docker containers images become containers when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging.</p></blockquote><p>当 Docker 的容器镜像在 Docker 引擎中运行的时候会成为容器。而且无论是 Linux 还是基于 Windows 的应用，在各种基础架构中都能良好的运行。容器能够隔离软件的运行环境以确保他们的工作表现是一致的，即使是开发和生产环境是存在些许的差异。</p><h3 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h3><p>那么容器和虚拟机之间有什么区别呢？</p><blockquote><p>Containers and virtual machines have similar resource isolation and allocation benefits, but function differently because containers virtualize the operating system instead of hardware. Containers are more portable and efficient.</p></blockquote><p>容器和虚拟机都有着类似的资源隔离和分配机制，但是两者的功能不尽相同。因为容器是基于操作系统层面的虚拟化，而虚拟机是基于硬件的虚拟化。所以，相对于虚拟机，容器更加的轻量以及高效。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590558227231-5c9e0c3f-2595-429b-959d-f84d727ed419.png"></p><blockquote><p>Containers are an abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same machine and share the OS kernel with other containers, each running as isolated processes in user space. Containers take up less space than VMs (container images are typically tens of MBs in size), can handle more applications and require fewer VMs and Operating systems.</p></blockquote><p>容器是在应用层的抽象，它封装了代码以及相关的依赖。多个容器可以运行在数相同的机器上，并且与其他容器共享系统的内核。每个容器运行的进程都是在用户态中隔离的。容器相对于虚拟机消耗更少的空间(容器镜像通常只有十多兆的大小）。只需要更少的虚拟机和操作系统资源，就可以运行更多的应用。</p><blockquote><p>Virtual machines (VMs) are an abstraction of physical hardware turning one server into many servers. The hypervisor allows multiple VMs to run on a single machine. Each VM includes a full copy of an operating system, the application, necessary binaries and libraries - taking up tens of GBs. VMs can also be slow to boot.</p></blockquote><p>虚拟机是对物理硬件的抽象，可以将一台服务器转化为多台服务器。Hypervisor 允许多个虚拟机运行在单台机子上。每个虚拟机都包含了一个完整的操作系统，以及应用程序、必不可少的二进制文件和库 - 其花费的空间通常是十多 GB。虚拟机启动的更慢。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590558971581-58c8e33c-a56b-413e-8fc2-8245881b50ae.png"></p><p>Containers and VMs used together provide a great deal of flexibility in deploying and managing app.</p><p>容器和虚拟机的结合，可以让我们更加灵活的部署和管理应用。</p><h3 id="docker的架构"><a href="#docker的架构" class="headerlink" title="docker的架构"></a>docker的架构</h3><blockquote><p>Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface.</p></blockquote><p>Docker 使用的是 C&#x2F;S (客户端&#x2F;服务器) 架构。由 Docker 的客户端区请求 Docker 引擎，由其完成 Docker 容器从构建、运行到分发的生命周期。Docker 的客户端以及 Docker 引擎可以运行在同一个系统中，或者你可以使用客户端连接到远程的 Docker 引擎。Docker 的客户端和 Docker 引擎通过 REST API 来进行通信，或者通过 UNIX Sockets 或网络接口。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/502915/1590582126138-48d5a861-2bbc-45d8-939d-82426ed14b13.png"></p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>安装 Docker 在 CentOS7 中，下面给出 Shell 的脚本，已经将镜像更换外阿里云:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">## Install use yum</span><br><span class="line">yum install -y yum-utils</span><br><span class="line">## 设置yum源</span><br><span class="line">### （中央仓库）</span><br><span class="line">yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">### （阿里仓库）</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">## 部署docker</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line">## Start Service</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">docker --version</span><br><span class="line">## 如果出现没有权限，可以将用户添加到 docker 的用户组中</span><br><span class="line">gpasswd -a vagrant docker</span><br><span class="line"></span><br><span class="line">## Modify docker registry image</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>其他的系统或发行版，请参考官方文档: <a href="https://docs.docker.com/engine/install/">Docker Install</a> 。官方脚本安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;curl -sSL https://get.docker.com/ | sh&quot;</span><br><span class="line">dockerd-rootless-setuptool.sh install</span><br><span class="line">## 将下面这两行追加到 ~/.bashrc 配置文件中</span><br><span class="line">export PATH=/usr/bin:$PATH</span><br><span class="line">export DOCKER_HOST=unix:///run/user/1000/docker.sock</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Docker 是 C&#x2F;S 架构的，包含 Docker Cli 以及 Docker Engine，我们可以通过 Docker Cli 来操作 Docker Engine。</p><p>我们可以使用 Docker 来打包应用，打包后的应用成为了 Docker 容器镜像。而 Docker 容器镜像在 Docker Engine 中运行的时候，我们就称之为容器或者说是容器的实例。</p><p>另外我们也对比了容器和虚拟机的区别，容器相对虚拟机更加的轻量级，而在实际的生产中，他们都不是孤立存在的，而是相互结合，共同作用于我们的应用的生产、部署过程中。</p><p><strong>容器的本质是进程</strong>，<strong>在进程的基础上对资源进行隔离、限制。</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;海纳百川，有容乃大；壁立千仞，无欲则刚。    ——林则徐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是docker？&quot;&gt;&lt;a href=&quot;#什么是docker？&quot; class=&quot;headerlink&quot; title=&quot;什么是docker？&quot;&gt;&lt;/a&gt;什么是docker？&lt;/h3&gt;&lt;p&gt;什么是 Docker，它是一个开源的应用容器引擎。首先它是开源的，使用 Go 语言编写。接着，他是一个应用容器引擎。容器，是用来承装内容，而此处的内容指的是应用，即我们开发出来的软件系统。既然是软件，就会有其运行环境。既然是系统，就会有很多的模块、组建、依赖。&lt;strong&gt;而 Docker 就可以将软件系统(application)这一切打包、存储、发行、运行、管理、更新乃至销毁。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么是容器？我们来看看 Docker 官网上的一篇介绍 —— &lt;a href=&quot;https://www.docker.com/resources/what-container&quot;&gt;What is a Container?&lt;/a&gt; 接下来的内容，是我对这篇文章的翻译。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="http://example.com/categories/docker/"/>
    
    
    <category term="容器" scheme="http://example.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
</feed>
